diff -urN linux.old/arch/mips/Kconfig linux.dev/arch/mips/Kconfig
--- linux.old/arch/mips/Kconfig	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/arch/mips/Kconfig	2006-12-14 04:09:50.000000000 +0100
@@ -728,6 +728,19 @@
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select TOSHIBA_BOARDS
 
+config MIKROTIK_RB500
+	bool "Support for RB5xx boards"
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SWAP_IO_SPACE
+	select DMA_NONCOHERENT
+	help
+	  Support the Mikrotik(tm) Routerboard 500 series,
+	  such as the RB532.
+
 config TOSHIBA_RBTX4927
 	bool "Toshiba TBTX49[23]7 board"
 	select DMA_NONCOHERENT
@@ -1015,7 +1028,7 @@
 
 config MIPS_L1_CACHE_SHIFT
 	int
-	default "4" if MACH_DECSTATION
+	default "4" if MACH_DECSTATION || MIKROTIK_RB500
 	default "7" if SGI_IP27
 	default "5"
 
diff -urN linux.old/arch/mips/Makefile linux.dev/arch/mips/Makefile
--- linux.old/arch/mips/Makefile	2006-12-14 03:13:55.000000000 +0100
+++ linux.dev/arch/mips/Makefile	2006-12-14 04:09:50.000000000 +0100
@@ -586,6 +586,13 @@
 load-$(CONFIG_TOSHIBA_JMR3927)	+= 0xffffffff80050000
 
 #
+# Routerboard 532 board
+#
+core-$(CONFIG_MIKROTIK_RB500)	+= arch/mips/rb500/
+cflags-$(CONFIG_MIKROTIK_RB500) += -Iinclude/asm-mips/rc32434
+load-$(CONFIG_MIKROTIK_RB500)	+= 0xffffffff80101000
+
+#
 # Toshiba RBTX4927 board or
 # Toshiba RBTX4937 board
 #
diff -urN linux.old/arch/mips/mm/tlbex.c linux.dev/arch/mips/mm/tlbex.c
--- linux.old/arch/mips/mm/tlbex.c	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/arch/mips/mm/tlbex.c	2006-12-14 04:09:50.000000000 +0100
@@ -874,7 +874,6 @@
 	case CPU_R10000:
 	case CPU_R12000:
 	case CPU_R14000:
-	case CPU_4KC:
 	case CPU_SB1:
 	case CPU_SB1A:
 	case CPU_4KSC:
@@ -902,6 +901,7 @@
 		tlbw(p);
 		break;
 
+	case CPU_4KC:
 	case CPU_4KEC:
 	case CPU_24K:
 	case CPU_34K:
diff -urN linux.old/arch/mips/pci/fixup-rb500.c linux.dev/arch/mips/pci/fixup-rb500.c
--- linux.old/arch/mips/pci/fixup-rb500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/fixup-rb500.c	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/rc32434/rc32434.h>
+
+static int __devinitdata irq_map[2][12] = {
+	{ 0, 0, 2, 3, 2, 3, 0, 0, 0, 0, 0, 1 },
+	{ 0, 0, 1, 3, 0, 2, 1, 3, 0, 2, 1, 3 }
+};
+
+int __devinit pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = 0;
+
+	if (dev->bus->number < 2 && PCI_SLOT(dev->devfn) < 12) {
+		irq = irq_map[dev->bus->number][PCI_SLOT(dev->devfn)];
+	}
+	return irq + GROUP4_IRQ_BASE + 4;
+}
+
diff -urN linux.old/arch/mips/pci/Makefile linux.dev/arch/mips/pci/Makefile
--- linux.old/arch/mips/pci/Makefile	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/arch/mips/pci/Makefile	2006-12-14 04:09:50.000000000 +0100
@@ -53,3 +53,4 @@
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
+obj-$(CONFIG_MIKROTIK_RB500)	+= pci-rc32434.o ops-rc32434.o fixup-rb500.o
diff -urN linux.old/arch/mips/pci/ops-rc32434.c linux.dev/arch/mips/pci/ops-rc32434.c
--- linux.old/arch/mips/pci/ops-rc32434.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/ops-rc32434.c	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,218 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     pci_ops for IDT EB434 board
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *  Copyright 2006 Felix Fietkau <nbd@openwrt.org>
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/pci.h> 
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+
+#define PCI_CFG_SET(bus,slot,func,off) \
+	(rc32434_pci->pcicfga = (0x80000000 | \
+				((bus) << 16) | ((slot)<<11) | \
+				((func)<<8) | (off)))
+
+static inline int config_access(unsigned char access_type, struct pci_bus *bus,
+                         unsigned int devfn, unsigned char where,
+                         u32 * data)
+{ 
+	unsigned int slot = PCI_SLOT(devfn);
+	u8 func = PCI_FUNC(devfn);
+	
+	/* Setup address */
+	PCI_CFG_SET(bus->number, slot, func, where);
+	rc32434_sync();
+	
+	if (access_type == PCI_ACCESS_WRITE)
+		rc32434_pci->pcicfgd = *data;
+	else
+		*data = rc32434_pci->pcicfgd;
+	
+	rc32434_sync();
+	
+	return 0;
+}
+
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int read_config_byte(struct pci_bus *bus, unsigned int devfn,
+                            int where, u8 * val)
+{
+	u32 data;
+	int ret;
+	
+	ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);
+	*val = (data >> ((where & 3) << 3)) & 0xff;
+	return ret;
+}
+
+static int read_config_word(struct pci_bus *bus, unsigned int devfn,
+                            int where, u16 * val)
+{
+	u32 data;
+	int ret;
+	
+	ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);
+	*val = (data >> ((where & 3) << 3)) & 0xffff;
+	return ret;
+}
+
+static int read_config_dword(struct pci_bus *bus, unsigned int devfn,
+                             int where, u32 * val)
+{
+	int ret;
+	int delay = 1;
+
+	if (bus->number == 0 && PCI_SLOT(devfn) > 21)
+		return 0;
+
+retry:
+	ret = config_access(PCI_ACCESS_READ, bus, devfn, where, val);
+	
+	/* PCI scan: check for invalid values, device may not have
+	 * finished initializing */
+
+	if (where == PCI_VENDOR_ID) {
+		if (ret == 0xffffffff || ret == 0x00000000 ||
+			ret == 0x0000ffff || ret == 0xffff0000) {
+
+			if (delay > 4)
+				return 0;
+
+			delay *= 2;
+			msleep(delay);
+			goto retry;
+		}
+	}
+	
+	return ret;
+}
+
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where,
+                  u8 val)
+{
+	u32 data = 0;
+	
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))
+		return -1;
+	
+	data = (data & ~(0xff << ((where & 3) << 3))) |
+		(val << ((where & 3) << 3));
+	
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
+		return -1;
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where,
+                  u16 val)
+{
+	u32 data = 0;
+	
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))
+		return -1;
+	
+	data = (data & ~(0xffff << ((where & 3) << 3))) |
+		(val << ((where & 3) << 3));
+	
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
+		return -1;
+	
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int 
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where,
+                   u32 val)
+{
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))
+		return -1;
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1: 
+		return read_config_byte(bus, devfn, where, (u8 *) val);
+	case 2: 
+		return read_config_word(bus, devfn, where, (u16 *) val);
+	default:
+		return read_config_dword(bus, devfn, where, val);
+	}
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 val)
+{
+	switch (size) {
+	case 1: 
+		return write_config_byte(bus, devfn, where, (u8) val);
+	case 2: 
+		return write_config_word(bus, devfn, where, (u16) val);
+	default:
+		return write_config_dword(bus, devfn, where, val);
+	}
+}
+
+struct pci_ops rc32434_pci_ops = {
+	.read =  pci_config_read,
+	.write = pci_config_write,
+};
diff -urN linux.old/arch/mips/pci/pci-rc32434.c linux.dev/arch/mips/pci/pci-rc32434.c
--- linux.old/arch/mips/pci/pci-rc32434.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/pci-rc32434.c	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,234 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     PCI initialization for IDT EB434 board
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/autoconf.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/pci.h>
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+/* define an unsigned array for the PCI registers */
+unsigned int korinaCnfgRegs[25] = {
+	KORINA_CNFG1,	 KORINA_CNFG2,  KORINA_CNFG3,  KORINA_CNFG4,
+	KORINA_CNFG5,	 KORINA_CNFG6,  KORINA_CNFG7,  KORINA_CNFG8,
+	KORINA_CNFG9,	 KORINA_CNFG10, KORINA_CNFG11, KORINA_CNFG12,
+	KORINA_CNFG13, KORINA_CNFG14, KORINA_CNFG15, KORINA_CNFG16,
+	KORINA_CNFG17, KORINA_CNFG18, KORINA_CNFG19, KORINA_CNFG20,
+	KORINA_CNFG21, KORINA_CNFG22, KORINA_CNFG23, KORINA_CNFG24
+};
+static struct resource rc32434_res_pci_mem1;
+static struct resource rc32434_res_pci_mem2;
+
+static struct resource rc32434_res_pci_mem1 = {
+	.name = "PCI MEM1",
+	.start = 0x50000000,
+	.end = 0x5FFFFFFF,
+	.flags = IORESOURCE_MEM,
+	.parent = &rc32434_res_pci_mem1,
+	.sibling = NULL,
+	.child = &rc32434_res_pci_mem2
+};
+
+static struct resource rc32434_res_pci_mem2 = {
+	.name = "PCI Mem2",
+	.start = 0x60000000,
+	.end = 0x6FFFFFFF,
+	.flags = IORESOURCE_MEM,
+	.parent = &rc32434_res_pci_mem1,
+	.sibling = NULL,
+	.child = NULL
+};
+
+static struct resource rc32434_res_pci_io1 = {
+	.name = "PCI I/O1",
+	.start = 0x18800000,
+	.end = 0x188FFFFF,
+	.flags = IORESOURCE_IO,
+};
+
+extern struct pci_ops rc32434_pci_ops;
+
+#define PCI_MEM1_START	PCI_ADDR_START
+#define PCI_MEM1_END	PCI_ADDR_START + CPUTOPCI_MEM_WIN - 1
+#define PCI_MEM2_START	PCI_ADDR_START + CPUTOPCI_MEM_WIN
+#define PCI_MEM2_END	PCI_ADDR_START + ( 2* CPUTOPCI_MEM_WIN)  - 1
+#define PCI_IO1_START	PCI_ADDR_START + (2 * CPUTOPCI_MEM_WIN)
+#define PCI_IO1_END 	PCI_ADDR_START + (2* CPUTOPCI_MEM_WIN) + CPUTOPCI_IO_WIN -1
+#define PCI_IO2_START	PCI_ADDR_START + (2 * CPUTOPCI_MEM_WIN) + CPUTOPCI_IO_WIN
+#define PCI_IO2_END 	PCI_ADDR_START + (2* CPUTOPCI_MEM_WIN) + (2 * CPUTOPCI_IO_WIN) -1
+
+
+struct pci_controller rc32434_controller2;
+
+struct pci_controller rc32434_controller = {
+	.pci_ops 	= &rc32434_pci_ops,
+	.mem_resource 	= &rc32434_res_pci_mem1,
+	.io_resource 	= &rc32434_res_pci_io1,
+	.mem_offset     = 0,
+	.io_offset      = 0,
+
+};
+
+#ifdef __MIPSEB__
+#define PCI_ENDIAN_FLAG PCILBAC_sb_m
+#else
+#define PCI_ENDIAN_FLAG 0
+#endif
+
+static int __init rc32434_pcibridge_init(void)
+{
+	unsigned int pcicValue, pcicData = 0;
+	unsigned int dummyRead, pciCntlVal;
+	int loopCount;
+	unsigned int pciConfigAddr;
+
+	pcicValue = rc32434_pci->pcic;
+	pcicValue = (pcicValue >> PCIM_SHFT) & PCIM_BIT_LEN;
+	if (!((pcicValue == PCIM_H_EA) ||
+		 (pcicValue == PCIM_H_IA_FIX) ||
+		(pcicValue == PCIM_H_IA_RR))) {
+		printk("PCI init error!!!\n");
+		/* Not in Host Mode, return ERROR */
+		return -1;
+	}
+	/* Enables the Idle Grant mode, Arbiter Parking */
+	pcicData |=(PCIC_igm_m|PCIC_eap_m|PCIC_en_m);
+	rc32434_pci->pcic = pcicData; /* Enable the PCI bus Interface */
+	/* Zero out the PCI status & PCI Status Mask */
+	for(;;)
+	{
+	   pcicData = rc32434_pci->pcis;
+	   if (!(pcicData & PCIS_rip_m))
+		    break;
+	}
+
+	rc32434_pci->pcis = 0;
+	rc32434_pci->pcism = 0xFFFFFFFF;
+	/* Zero out the PCI decoupled registers */
+	rc32434_pci->pcidac=0; /* disable PCI decoupled accesses at initialization */
+	rc32434_pci->pcidas=0; /* clear the status */
+	rc32434_pci->pcidasm=0x0000007F; /* Mask all the interrupts */
+	/* Mask PCI Messaging Interrupts */
+	rc32434_pci_msg->pciiic = 0;
+	rc32434_pci_msg->pciiim = 0xFFFFFFFF;
+	rc32434_pci_msg->pciioic = 0;
+	rc32434_pci_msg->pciioim = 0;
+
+
+	/* Setup PCILB0 as Memory Window */
+	rc32434_pci->pcilba[0].a = (unsigned int) (PCI_ADDR_START);
+
+	/* setup the PCI map address as same as the local address */
+
+	rc32434_pci->pcilba[0].m = (unsigned int) (PCI_ADDR_START);
+
+
+	/* Setup PCILBA1 as MEM */
+	rc32434_pci->pcilba[0].c = ( ((SIZE_256MB & 0x1f) << PCILBAC_size_b) | PCI_ENDIAN_FLAG);
+	dummyRead = rc32434_pci->pcilba[0].c; /* flush the CPU write Buffers */
+	rc32434_pci->pcilba[1].a = 0x60000000;
+	rc32434_pci->pcilba[1].m = 0x60000000;
+
+	/* setup PCILBA2 as IO Window*/
+	rc32434_pci->pcilba[1].c = (((SIZE_256MB & 0x1f) << PCILBAC_size_b )| PCI_ENDIAN_FLAG);
+	dummyRead = rc32434_pci->pcilba[1].c; /* flush the CPU write Buffers */
+	rc32434_pci->pcilba[2].a = 0x18C00000;
+	rc32434_pci->pcilba[2].m = 0x18FFFFFF;
+
+	/* setup PCILBA2 as IO Window*/
+	rc32434_pci->pcilba[2].c = (((SIZE_4MB & 0x1f) << PCILBAC_size_b) | PCI_ENDIAN_FLAG );
+	dummyRead = rc32434_pci->pcilba[2].c; /* flush the CPU write Buffers */
+
+	/* Setup PCILBA3 as IO Window */
+	rc32434_pci->pcilba[3].a = 0x18800000;
+	rc32434_pci->pcilba[3].m = 0x18800000;
+	rc32434_pci->pcilba[3].c = ( (((SIZE_1MB & 0x1ff) << PCILBAC_size_b) | PCILBAC_msi_m) | PCI_ENDIAN_FLAG);
+	dummyRead = rc32434_pci->pcilba[3].c; /* flush the CPU write Buffers */
+
+	pciConfigAddr=(unsigned int)(0x80000004);
+	for(loopCount=0;loopCount<24;loopCount++){
+		rc32434_pci->pcicfga=pciConfigAddr;
+		dummyRead=rc32434_pci->pcicfga;
+		rc32434_pci->pcicfgd = korinaCnfgRegs[loopCount];
+		dummyRead=rc32434_pci->pcicfgd;
+		pciConfigAddr += 4;
+	}
+	rc32434_pci->pcitc = (unsigned int)((PCITC_RTIMER_VAL&0xff) << PCITC_rtimer_b)
+		| ((PCITC_DTIMER_VAL&0xff) << PCITC_dtimer_b);
+
+	pciCntlVal=rc32434_pci->pcic;
+	pciCntlVal &=~(PCIC_tnr_m);
+	rc32434_pci->pcic = pciCntlVal;
+	pciCntlVal=rc32434_pci->pcic;
+	return 0;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	if (PCI_SLOT(dev->devfn) == 6 && dev->bus->number == 0) {
+		/* disable prefetched memory range */
+		pci_write_config_word(dev, PCI_PREF_MEMORY_LIMIT, 0);
+		pci_write_config_word(dev, PCI_PREF_MEMORY_BASE, 0x10);
+
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 4);
+	}
+	return 0;
+}
+
+static int __init rc32434_pci_init(void)
+{
+	printk("PCI: Initializing PCI\n");
+
+	ioport_resource.start = rc32434_res_pci_io1.start;
+	ioport_resource.end = rc32434_res_pci_io1.end;
+
+	rc32434_pcibridge_init();
+
+	register_pci_controller(&rc32434_controller);
+	rc32434_sync();
+}
+
+arch_initcall(rc32434_pci_init);
+
diff -urN linux.old/arch/mips/rb500/devices.c linux.dev/arch/mips/rb500/devices.c
--- linux.old/arch/mips/rb500/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/devices.c	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,210 @@
+/*
+ *  RouterBoard 500 Platform devices
+ *
+ *  Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  $Id$
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/dma.h>
+#include <asm/rc32434/dma_v.h>
+#include <asm/rc32434/eth.h>
+#include <asm/rc32434/rb.h>
+
+#define ETH0_DMA_RX_IRQ   	GROUP1_IRQ_BASE + 0
+#define ETH0_DMA_TX_IRQ   	GROUP1_IRQ_BASE + 1 
+#define ETH0_RX_OVR_IRQ   	GROUP3_IRQ_BASE + 9
+#define ETH0_TX_UND_IRQ   	GROUP3_IRQ_BASE + 10
+
+#define ETH0_RX_DMA_ADDR  (DMA0_PhysicalAddress + 0*DMA_CHAN_OFFSET)
+#define ETH0_TX_DMA_ADDR  (DMA0_PhysicalAddress + 1*DMA_CHAN_OFFSET)
+
+static struct resource korina_dev0_res[] = {
+	{
+		.name  = "korina_regs",
+		.start = ETH0_PhysicalAddress,
+		.end   = ETH0_PhysicalAddress + sizeof(ETH_t),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name  = "korina_rx",
+		.start = ETH0_DMA_RX_IRQ,
+		.end   = ETH0_DMA_RX_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_tx",
+		.start = ETH0_DMA_TX_IRQ,
+		.end   = ETH0_DMA_TX_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_ovr",
+		.start = ETH0_RX_OVR_IRQ,
+		.end   = ETH0_RX_OVR_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_und",
+		.start = ETH0_TX_UND_IRQ,
+		.end   = ETH0_TX_UND_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_dma_rx",
+		.start = ETH0_RX_DMA_ADDR,
+		.end   = ETH0_RX_DMA_ADDR + DMA_CHAN_OFFSET - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name  = "korina_dma_tx",
+		.start = ETH0_TX_DMA_ADDR,
+		.end   = ETH0_TX_DMA_ADDR + DMA_CHAN_OFFSET - 1,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+static struct korina_device korina_dev0_data = {
+	.name = "korina0",
+	.mac = { 0xde, 0xca, 0xff, 0xc0, 0xff, 0xee }
+};
+
+static struct platform_device korina_dev0 = {
+	.id = 0,
+	.name = "korina",
+	.dev.platform_data = &korina_dev0_data,
+	.resource = korina_dev0_res,
+	.num_resources = ARRAY_SIZE(korina_dev0_res),
+};
+
+
+#define CF_GPIO_NUM 13
+
+static struct resource cf_slot0_res[] = {
+	{
+		.name  = "cf_membase",
+		.flags = IORESOURCE_MEM
+	},
+	{
+		.name  = "cf_irq",
+		.start = (8 + 4 * 32 + CF_GPIO_NUM),  /* 149 */
+		.end   = (8 + 4 * 32 + CF_GPIO_NUM),
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct cf_device cf_slot0_data = {
+	.gpio_pin = 13
+};
+
+static struct platform_device cf_slot0 = {
+	.id = 0,
+	.name = "rb500-cf",
+	.dev.platform_data = &cf_slot0_data,
+	.resource = cf_slot0_res,
+	.num_resources = ARRAY_SIZE(cf_slot0_res),
+};
+
+/* Resources and device for NAND.  There is no data needed and no irqs, so just define the memory used. */
+static struct resource nand_slot0_res[] = {
+	{
+		.name = "nand_membase",
+		.flags = IORESOURCE_MEM	
+	}
+};
+ 
+static struct platform_device nand_slot0 = {
+	.id = 0,
+	.name = "rb500-nand",
+	.resource = nand_slot0_res,
+	.num_resources = ARRAY_SIZE(nand_slot0_res),
+};
+
+
+static struct platform_device *rb500_devs[] = {
+	&korina_dev0,
+	&nand_slot0,
+	&cf_slot0
+};
+
+static void __init parse_mac_addr(char* macstr)
+{
+	int i, j;
+	unsigned char result, value;
+	
+	for (i=0; i<6; i++) {
+		result = 0;
+		if (i != 5 && *(macstr+2) != ':') {
+			return;
+		}				
+		for (j=0; j<2; j++) {
+			if (isxdigit(*macstr) && (value = isdigit(*macstr) ? *macstr-'0' : 
+						  toupper(*macstr)-'A'+10) < 16) {
+				result = result*16 + value;
+				macstr++;
+			} 
+			else return;
+		}
+		
+		macstr++; 
+		korina_dev0_data.mac[i] = result;
+	}
+}
+
+
+/* DEVICE CONTROLLER 1 */
+#define CFG_DC_DEV1 (void*)0xb8010010
+#define CFG_DC_DEV2 (void*)0xb8010020
+#define CFG_DC_DEVBASE    0x0
+#define CFG_DC_DEVMASK    0x4
+#define CFG_DC_DEVC       0x8
+#define CFG_DC_DEVTC      0xC
+
+
+static int __init plat_setup_devices(void)
+{
+	/* Look for the CF card reader */
+	if (!readl(CFG_DC_DEV1 + CFG_DC_DEVMASK))
+		rb500_devs[1] = NULL;
+	else {
+		cf_slot0_res[0].start = readl(CFG_DC_DEV1 + CFG_DC_DEVBASE);
+		cf_slot0_res[0].end = cf_slot0_res[0].start + 0x1000;
+	}
+	
+	/* There is always a NAND device */
+	nand_slot0_res[0].start = readl( CFG_DC_DEV2 + CFG_DC_DEVBASE);
+	nand_slot0_res[0].end = nand_slot0_res[0].start + 0x1000;
+		
+	return platform_add_devices(rb500_devs, ARRAY_SIZE(rb500_devs));
+}
+
+static int __init setup_kmac(char *s)
+{
+    printk("korina mac = %s\n",s);
+	parse_mac_addr(s);
+    return 0;
+}
+
+__setup("kmac=", setup_kmac);
+arch_initcall(plat_setup_devices);
+
+
diff -urN linux.old/arch/mips/rb500/irq.c linux.dev/arch/mips/rb500/irq.c
--- linux.old/arch/mips/rb500/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/irq.c	2006-12-14 04:14:16.000000000 +0100
@@ -0,0 +1,264 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	RC32434 interrupt routines.
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/gpio.h>
+
+extern void set_debug_traps(void);
+extern irq_cpustat_t irq_stat [NR_CPUS];
+unsigned int local_bh_count[NR_CPUS];
+unsigned int local_irq_count[NR_CPUS];
+
+static unsigned int startup_irq(unsigned int irq);
+static void rb500_end_irq(unsigned int irq_nr);
+static void mask_and_ack_irq(unsigned int irq_nr);
+static void rb500_enable_irq(unsigned int irq_nr);
+static void rb500_disable_irq(unsigned int irq_nr);
+
+extern void __init init_generic_irq(void);
+
+typedef struct {
+  u32 mask;       /* mask of valid bits in pending/mask registers */
+  volatile u32 *base_addr;
+} intr_group_t;
+
+#define RC32434_NR_IRQS  (GROUP4_IRQ_BASE + 32)
+
+#if (NR_IRQS < RC32434_NR_IRQS)
+#error Too little irqs defined. Did you override <asm/irq.h> ?
+#endif
+
+static const intr_group_t intr_group[NUM_INTR_GROUPS] = {
+  { 0x0000efff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 0 * IC_GROUP_OFFSET) },
+  { 0x00001fff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 1 * IC_GROUP_OFFSET) },
+  { 0x00000007, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 2 * IC_GROUP_OFFSET) },
+  { 0x0003ffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 3 * IC_GROUP_OFFSET) },
+  { 0xffffffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 4 * IC_GROUP_OFFSET) }
+};
+
+#define READ_PEND(base) (*(base))
+#define READ_MASK(base) (*(base + 2))
+#define WRITE_MASK(base, val) (*(base + 2) = (val))
+
+static inline int irq_to_group(unsigned int irq_nr)
+{
+  return ((irq_nr - GROUP0_IRQ_BASE) >> 5);
+}
+
+static inline int group_to_ip(unsigned int group)
+{
+  return group + 2;
+}
+
+static inline void enable_local_irq(unsigned int ip)
+{
+  int ipnum = 0x100 << ip;
+  clear_c0_cause(ipnum);
+  set_c0_status(ipnum);
+}
+
+static inline void disable_local_irq(unsigned int ip)
+{
+  int ipnum = 0x100 << ip;
+  clear_c0_status(ipnum);
+}
+
+static inline void ack_local_irq(unsigned int ip)
+{
+  int ipnum = 0x100 << ip;
+  clear_c0_cause(ipnum);
+}
+
+static void rb500_enable_irq(unsigned int irq_nr)
+{
+  int           ip = irq_nr - GROUP0_IRQ_BASE;
+  unsigned int  group, intr_bit;
+  volatile unsigned int  *addr;
+  
+  
+  if (ip < 0)
+    enable_local_irq(irq_nr);
+  else {
+    group = ip >> 5;
+ 
+    ip &= (1<<5)-1;
+    intr_bit = 1 << ip;
+ 
+    enable_local_irq(group_to_ip(group));
+    
+    addr = intr_group[group].base_addr;
+    WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);
+  }
+}
+
+static void rb500_disable_irq(unsigned int irq_nr)
+{
+  int           ip = irq_nr - GROUP0_IRQ_BASE;
+  unsigned int  group, intr_bit, mask;
+  volatile unsigned int  *addr;
+  
+  if (ip < 0) {
+	disable_local_irq(irq_nr);
+    }else{
+    group = ip >> 5;
+    
+    ip &= (1<<5) -1;
+    intr_bit = 1 << ip;
+    addr = intr_group[group].base_addr;
+    mask = READ_MASK(addr);
+    mask |= intr_bit;
+    WRITE_MASK(addr,mask);
+   
+    /*
+     * if there are no more interrupts enabled in this
+     * group, disable corresponding IP
+     */
+    if (mask == intr_group[group].mask)
+      disable_local_irq(group_to_ip(group));
+  }
+}
+
+static unsigned int startup_irq(unsigned int irq_nr)
+{
+  rb500_enable_irq(irq_nr);
+  return 0; 
+}
+
+static void shutdown_irq(unsigned int irq_nr)
+{
+  rb500_disable_irq(irq_nr);
+  return;
+}
+
+static void mask_and_ack_irq(unsigned int irq_nr)
+{
+  rb500_disable_irq(irq_nr);
+  ack_local_irq(group_to_ip(irq_to_group(irq_nr)));
+}
+
+static void rb500_end_irq(unsigned int irq_nr)
+{
+
+  int ip = irq_nr - GROUP0_IRQ_BASE;
+  unsigned int intr_bit, group;
+  volatile unsigned int *addr;
+
+	if ((irq_desc[irq_nr].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		printk("warning: end_irq %d did not enable (%x)\n", 
+			irq_nr, irq_desc[irq_nr].status);
+		return;
+	}
+	
+	if (ip < 0) {
+		enable_local_irq(irq_nr);
+	} else {
+		group = ip >> 5;
+	
+		ip &= (1 << 5) - 1;
+		intr_bit = 1 << ip;
+	
+		if (irq_nr >= GROUP4_IRQ_BASE && irq_nr <= (GROUP4_IRQ_BASE + 13)) {
+			gpio->gpioistat = gpio->gpioistat & ~intr_bit;
+		}
+	
+		enable_local_irq(group_to_ip(group));
+	
+		addr = intr_group[group].base_addr;
+		WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);
+	}
+}
+
+static struct hw_interrupt_type rc32434_irq_type = {
+  .typename = "RB500",
+  .startup = startup_irq,
+  .shutdown = shutdown_irq,
+  .enable = rb500_enable_irq,
+  .disable = rb500_disable_irq,
+  .ack = mask_and_ack_irq,
+  .end = rb500_end_irq,
+};
+
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	printk("Initializing IRQ's: %d out of %d\n", RC32434_NR_IRQS, NR_IRQS);
+	memset(irq_desc, 0, sizeof(irq_desc));
+  
+	for (i = 0; i < RC32434_NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].chip = &rc32434_irq_type;
+		spin_lock_init(&irq_desc[i].lock);
+	}
+}
+
+/* Main Interrupt dispatcher */
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int ip, pend, group;
+	volatile unsigned int *addr;
+	unsigned int cp0_cause = read_c0_cause() & read_c0_status();
+
+	if (cp0_cause & CAUSEF_IP7) {
+		ll_timer_interrupt(7);
+	} else if ((ip = (cp0_cause & 0x7c00))) {
+		group = 21 - rc32434_clz(ip);
+
+		addr = intr_group[group].base_addr;
+
+		pend = READ_PEND(addr);
+		pend &= ~READ_MASK(addr); // only unmasked interrupts
+		pend = 39 - rc32434_clz(pend);
+		do_IRQ((group << 5) + pend);
+	}
+}
diff -urN linux.old/arch/mips/rb500/Makefile linux.dev/arch/mips/rb500/Makefile
--- linux.old/arch/mips/rb500/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/Makefile	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for the RB500 board specific parts of the kernel
+#
+
+obj-y	 += irq.o time.o setup.o serial.o prom.o misc.o devices.o
diff -urN linux.old/arch/mips/rb500/misc.c linux.dev/arch/mips/rb500/misc.c
--- linux.old/arch/mips/rb500/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/misc.c	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,56 @@
+#include <linux/module.h>
+#include <linux/kernel.h>   /* printk() */
+#include <linux/types.h>    /* size_t */
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <asm/rc32434/rb.h>
+
+#define GPIO_BADDR  0xb8050000
+
+
+static volatile unsigned char *devCtl3Base = 0;
+static unsigned char latchU5State = 0;
+static spinlock_t clu5Lock = SPIN_LOCK_UNLOCKED;
+
+void set434Reg(unsigned regOffs, unsigned bit, unsigned len, unsigned val) {
+    unsigned flags, data;
+    unsigned i = 0;
+    spin_lock_irqsave(&clu5Lock, flags);
+    data = *(volatile unsigned *) (IDT434_REG_BASE + regOffs);
+    for (i = 0; i != len; ++i) {
+	if (val & (1 << i)) data |= (1 << (i + bit));
+	else data &= ~(1 << (i + bit));
+    }
+    *(volatile unsigned *) (IDT434_REG_BASE + regOffs) = data;
+    spin_unlock_irqrestore(&clu5Lock, flags);
+}
+
+void changeLatchU5(unsigned char orMask, unsigned char nandMask) {
+    unsigned flags;
+    spin_lock_irqsave(&clu5Lock, flags);
+    latchU5State = (latchU5State | orMask) & ~nandMask;
+    if( !devCtl3Base) devCtl3Base = (volatile unsigned char *)
+	        KSEG1ADDR(*(volatile unsigned *) KSEG1ADDR(0x18010030));
+    *devCtl3Base = latchU5State;
+    spin_unlock_irqrestore(&clu5Lock, flags);
+}
+
+u32 gpio_get(gpio_func func)
+{
+	return readl((void *) GPIO_BADDR + func);
+}
+
+void gpio_set(gpio_func func, u32 mask, u32 value)
+{
+	u32 val = readl((void *) GPIO_BADDR + func);
+	
+	val &= ~mask;
+	val |= value & mask;
+	
+	writel(val, (void *) GPIO_BADDR + func);
+}
+
+EXPORT_SYMBOL(gpio_set);
+EXPORT_SYMBOL(gpio_get);
+EXPORT_SYMBOL(set434Reg);
+EXPORT_SYMBOL(changeLatchU5);
diff -urN linux.old/arch/mips/rb500/prom.c linux.dev/arch/mips/rb500/prom.c
--- linux.old/arch/mips/rb500/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/prom.c	2006-12-14 05:15:05.000000000 +0100
@@ -0,0 +1,161 @@
+/*
+* prom.c 
+**********************************************************************
+* P . Sadik Oct 10, 2003
+*
+* Started change log
+* idt_cpu_freq is make a kernel configuration parameter
+* idt_cpu_freq is exported so that other modules can use it.
+* Code cleanup
+**********************************************************************
+* P. Sadik Oct 20, 2003
+*
+* Removed NVRAM code from here, since they are already available under
+* nvram directory.
+* Added serial port initialisation.
+**********************************************************************
+**********************************************************************
+* P. Sadik Oct 30, 2003
+*
+* Added reset_cons_port
+**********************************************************************
+
+  P.Christeas, 2005-2006
+  Port to 2.6, add 2.6 cmdline parsing
+
+*/
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <asm/bootinfo.h>
+#include <linux/bootmem.h>
+#include <linux/ioport.h>
+#include <linux/blkdev.h>
+#include <asm/rc32434/ddr.h>
+
+#define PROM_ENTRY(x)   (0xbfc00000+((x)*8))
+extern void __init setup_serial_port(void);
+
+unsigned int idt_cpu_freq = 132000000;
+EXPORT_SYMBOL(idt_cpu_freq);
+unsigned int board_type = 500;
+EXPORT_SYMBOL(board_type);
+unsigned int gpio_bootup_state = 0;
+EXPORT_SYMBOL(gpio_bootup_state);
+
+
+char mips_mac_address[18] = "08:00:06:05:40:01";
+EXPORT_SYMBOL(mips_mac_address);
+
+/* what to append to cmdline when button is [not] pressed */
+#define GPIO_INIT_NOBUTTON ""
+#define GPIO_INIT_BUTTON   " 2"
+
+#ifdef CONFIG_MIKROTIK_RB500
+unsigned soft_reboot = 0;
+EXPORT_SYMBOL(soft_reboot);
+#endif
+
+#define SR_NMI			0x00180000      /* NMI */
+#define SERIAL_SPEED_ENTRY	0x00000001
+
+#ifdef CONFIG_REMOTE_DEBUG
+extern int remote_debug;
+#endif
+
+extern unsigned long mips_machgroup;
+extern unsigned long mips_machtype;
+
+#define FREQ_TAG   "HZ="
+#define GPIO_TAG   "gpio="
+#define KMAC_TAG   "kmac="
+#define MEM_TAG	   "mem="
+#define BOARD_TAG  "board="
+#define IGNORE_CMDLINE_MEM 1
+#define DEBUG_DDR
+
+void parse_soft_settings(unsigned *ptr, unsigned size);
+void parse_hard_settings(unsigned *ptr, unsigned size);
+
+void __init prom_setup_cmdline(void);
+
+void __init prom_init(void)
+{
+	DDR_t ddr = (DDR_t) DDR_VirtualAddress; /* define the pointer to the DDR registers */
+	phys_t memsize = 0-ddr->ddrmask;
+	
+	/* this should be the very first message, even before serial is properly initialized */
+	prom_setup_cmdline();
+	setup_serial_port();
+
+	mips_machgroup = MACH_GROUP_MIKROTIK;
+	soft_reboot = read_c0_status() & SR_NMI;
+	pm_power_off = NULL;
+
+	/*
+	 * give all RAM to boot allocator,
+	 * except for the first 0x400 and the last 0x200 bytes
+	 */
+	add_memory_region(ddr->ddrbase + 0x400, memsize - 0x600, BOOT_MEM_RAM);
+}
+
+void prom_free_prom_memory(void)
+{
+	/* FIXME: STUB */
+}
+
+void __init prom_setup_cmdline(void){
+	char cmd_line[CL_SIZE];
+	char *cp;
+	int prom_argc;
+	char **prom_argv, **prom_envp;
+	int i;
+	
+	prom_argc = fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+	
+	cp=cmd_line;
+		/* Note: it is common that parameters start at argv[1] and not argv[0],
+		however, our elf loader starts at [0] */
+	for(i=0;i<prom_argc;i++){
+		if (strncmp(prom_argv[i], FREQ_TAG, sizeof(FREQ_TAG) - 1) == 0) {
+			idt_cpu_freq = simple_strtoul(prom_argv[i] + sizeof(FREQ_TAG) - 1, 0, 10);
+			continue;
+		}
+#ifdef IGNORE_CMDLINE_MEM
+		/* parses out the "mem=xx" arg */
+		if (strncmp(prom_argv[i], MEM_TAG, sizeof(MEM_TAG) - 1) == 0) {
+			continue;
+		}
+#endif
+		if (i>0) *(cp++) = ' ';
+		if (strncmp(prom_argv[i], BOARD_TAG, sizeof(BOARD_TAG) - 1) == 0) {
+			board_type =  simple_strtoul(prom_argv[i] + sizeof(BOARD_TAG) - 1, 0, 10);
+		}
+		if (strncmp(prom_argv[i], GPIO_TAG, sizeof(GPIO_TAG) - 1) == 0) {
+			gpio_bootup_state =  simple_strtoul(prom_argv[i] + sizeof(GPIO_TAG) - 1, 0, 10);
+		}
+		strcpy(cp,prom_argv[i]);
+		cp+=strlen(prom_argv[i]);
+	}
+	
+	i=strlen(arcs_cmdline);
+	if (i>0){
+		*(cp++) = ' ';
+		strcpy(cp,arcs_cmdline);
+		cp+=strlen(arcs_cmdline);
+	}
+	if (gpio_bootup_state&0x02)
+		strcpy(cp,GPIO_INIT_NOBUTTON);
+	else
+		strcpy(cp,GPIO_INIT_BUTTON);
+	cmd_line[CL_SIZE-1] = '\0';
+	
+	strcpy(arcs_cmdline,cmd_line);
+}
+
diff -urN linux.old/arch/mips/rb500/serial.c linux.dev/arch/mips/rb500/serial.c
--- linux.old/arch/mips/rb500/serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/serial.c	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,77 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Serial port initialisation.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+#include <asm/rc32434/rc32434.h>
+
+extern unsigned int idt_cpu_freq;
+
+static struct uart_port serial_req = {
+	.type = PORT_16550A,
+	.line = 0,
+	.irq = RC32434_UART0_IRQ,
+	.flags = STD_COM_FLAGS,
+	.iotype = UPIO_MEM,
+	.membase = (char *) KSEG1ADDR(RC32434_UART0_BASE),
+//	.fifosize = 14
+	.regshift = 2
+};
+
+int __init setup_serial_port(void)
+{
+	serial_req.uartclk = idt_cpu_freq;
+
+	if (early_serial_setup(&serial_req))
+		return -ENODEV;
+	
+	return(0);
+}
diff -urN linux.old/arch/mips/rb500/setup.c linux.dev/arch/mips/rb500/setup.c
--- linux.old/arch/mips/rb500/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/setup.c	2006-12-14 04:51:12.000000000 +0100
@@ -0,0 +1,81 @@
+/*
+ * setup.c - boot time setup code
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/pgtable.h>
+#include <asm/reboot.h>
+#include <asm/addrspace.h>     /* for KSEG1ADDR() */
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/pci.h>
+
+#ifdef CONFIG_PCI
+extern void *rc32434_time_init(void);
+extern int __init rc32434_pcibridge_init(void);
+#endif
+
+#define epldMask ((volatile unsigned char *)0xB900000d)
+
+static void rb_machine_restart(char *command)
+{
+	/* just jump to the reset vector */
+	* (volatile unsigned *) KSEG1ADDR(0x18008000) = 0x80000001;
+	((void (*)(void))KSEG1ADDR(0x1FC00000u))();
+}
+
+static void rb_machine_halt(void)
+{
+	for(;;) continue;
+}
+
+#ifdef CONFIG_CPU_HAS_WB
+void (*__wbflush) (void);
+
+static void rb_write_buffer_flush(void)
+{
+	__asm__ __volatile__
+	    ("sync\n\t" "nop\n\t" "loop: bc0f loop\n\t" "nop\n\t");
+}
+#endif
+
+void __init plat_mem_setup(void)
+{
+	unsigned int pciCntlVal;
+
+	board_time_init = rc32434_time_init;
+
+#ifdef CONFIG_CPU_HAS_WB
+	__wbflush = rb_write_buffer_flush;
+#endif
+	_machine_restart = rb_machine_restart;
+	_machine_halt = rb_machine_halt;
+	/*_machine_power_off = rb_machine_power_halt;*/
+	pm_power_off = rb_machine_halt;
+
+	set_io_port_base(KSEG1);
+
+	pciCntlVal=rc32434_pci->pcic;
+	pciCntlVal &= 0xFFFFFF7;
+	rc32434_pci->pcic = pciCntlVal;
+
+#ifdef CONFIG_PCI
+	/* Enable PCI interrupts in EPLD Mask register */
+	*epldMask = 0x0;
+	*(epldMask + 1) = 0x0;
+#endif
+	write_c0_wired(0);
+}
+
+const char *get_system_type(void)
+{
+	return "MIPS RB500";
+}
diff -urN linux.old/arch/mips/rb500/time.c linux.dev/arch/mips/rb500/time.c
--- linux.old/arch/mips/rb500/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/time.c	2006-12-14 04:48:33.000000000 +0100
@@ -0,0 +1,93 @@
+/*
+****************************************************************************
+* Carsten Langgaard, carstenl@mips.com
+* Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+*
+***************************************************************************
+*
+*  This program is free software; you can distribute it and/or modify it
+*  under the terms of the GNU General Public License (Version 2) as
+*  published by the Free Software Foundation.
+*
+*  This program is distributed in the hope it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+*  for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; if not, write to the Free Software Foundation, Inc.,
+*  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+*
+****************************************************************************
+*
+* Setting up the clock on the MIPS boards.
+*
+****************************************************************************
+* P. Sadik Oct 10, 2003
+*
+* Started change log.
+* mips_counter_frequency is now calculated at run time, based on idt_cpu_freq.
+* Code cleanup
+****************************************************************************
+*/
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/mc146818rtc.h>
+#include <linux/irq.h>
+#include <linux/timex.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/debug.h>
+#include <asm/rc32434/rc32434.h>
+
+static unsigned long r4k_offset; /* Amount to incr compare reg each time */
+static unsigned long r4k_cur;    /* What counter should be at next timer irq */
+extern unsigned int mips_hpt_frequency;
+extern unsigned int idt_cpu_freq;
+
+/* 
+ * Figure out the r4k offset, the amount to increment the compare
+ * register for each time tick. There is no RTC available.
+ *
+ * The RC32434 counts at half the CPU *core* speed.
+ */
+static unsigned long __init cal_r4koff(void)
+{
+	mips_hpt_frequency = idt_cpu_freq * IDT_CLOCK_MULT / 2;
+	return (mips_hpt_frequency / HZ);
+}
+
+
+void __init rc32434_time_init(void)
+{
+	unsigned int est_freq, flags;
+
+	local_irq_save(flags);
+
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);
+
+	est_freq = 2*r4k_offset*HZ;	
+	est_freq += 5000;	/* round */
+	est_freq -= est_freq%10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, 
+	       (est_freq%1000000)*100/1000000);
+	local_irq_restore(flags);
+}
+
+void __init plat_timer_setup(struct irqaction *irq)
+{
+	/* we are using the cpu counter for timer interrupts */
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);
+
+	/* to generate the first timer interrupt */
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+}
+
diff -urN linux.old/drivers/pci/Makefile linux.dev/drivers/pci/Makefile
--- linux.old/drivers/pci/Makefile	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/drivers/pci/Makefile	2006-12-14 04:09:50.000000000 +0100
@@ -16,6 +16,7 @@
 
 # Build the PCI MSI interrupt support
 obj-$(CONFIG_PCI_MSI) += msi.o
+obj-$(CONFIG_MIKROTIK_RB500) += setup-irq.o
 
 # Build the Hypertransport interrupt support
 obj-$(CONFIG_HT_IRQ) += htirq.o
diff -urN linux.old/include/asm-mips/bootinfo.h linux.dev/include/asm-mips/bootinfo.h
--- linux.old/include/asm-mips/bootinfo.h	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/include/asm-mips/bootinfo.h	2006-12-14 04:09:50.000000000 +0100
@@ -212,6 +212,8 @@
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
 #define  MACH_NEC_MARKEINS	0	/* NEC EMMA2RH Mark-eins	*/
 
+#define MACH_GROUP_MIKROTIK    24 /* Mikrotik Boards			    */
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -urN linux.old/include/asm-mips/cpu.h linux.dev/include/asm-mips/cpu.h
--- linux.old/include/asm-mips/cpu.h	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/include/asm-mips/cpu.h	2006-12-14 04:09:50.000000000 +0100
@@ -200,7 +200,8 @@
 #define CPU_SB1A		62
 #define CPU_74K			63
 #define CPU_R14000		64
-#define CPU_LAST		64
+#define CPU_RC32300		65
+#define CPU_LAST		65
 
 /*
  * ISA Level encodings
diff -urN linux.old/include/asm-mips/rc32434/ddr.h linux.dev/include/asm-mips/rc32434/ddr.h
--- linux.old/include/asm-mips/rc32434/ddr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/ddr.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,173 @@
+#ifndef __IDT_DDR_H__
+#define __IDT_DDR_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * DDR register definition.
+ *
+ * File   : $Id: ddr.h,v 1.2 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *          $Log: ddr.h,v $
+ *          Revision 1.2  2002/06/06 18:34:03  astichte
+ *          Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *
+ *          Revision 1.1  2002/05/29 17:33:21  sysarch
+ *          jba File moved from vcode/include/idt/acacia
+ *
+ *
+ ******************************************************************************/
+
+enum
+{
+	DDR0_PhysicalAddress	= 0x18018000,
+	DDR_PhysicalAddress	= DDR0_PhysicalAddress,		// Default
+
+	DDR0_VirtualAddress	= 0xb8018000,
+	DDR_VirtualAddress	= DDR0_VirtualAddress,		// Default
+} ;
+
+typedef struct DDR_s
+{
+	u32	ddrbase ;
+	u32	ddrmask ;
+	u32	res1;
+	u32	res2;
+	u32	ddrc ;
+	u32	ddrabase ;
+	u32	ddramask ;
+	u32	ddramap ;
+	u32	ddrcust;
+	u32	ddrrdc;
+	u32	ddrspare;
+} volatile *DDR_t ;
+
+enum
+{
+	DDR0BASE_baseaddr_b	= 16,
+	DDR0BASE_baseaddr_m	= 0xffff0000,
+
+	DDR0MASK_mask_b		= 16,
+	DDR0MASK_mask_m		= 0xffff0000,
+
+	DDR1BASE_baseaddr_b	= 16,
+	DDR1BASE_baseaddr_m	= 0xffff0000,
+
+	DDR1MASK_mask_b		= 16,
+	DDR1MASK_mask_m		= 0xffff0000,
+
+	DDRC_ata_b		= 5,
+	DDRC_ata_m		= 0x000000E0,
+	DDRC_dbw_b		= 8,
+	DDRC_dbw_m		= 0x00000100,
+	DDRC_wr_b		= 9,
+	DDRC_wr_m		= 0x00000600,
+	DDRC_ps_b		= 11,
+	DDRC_ps_m		= 0x00001800,
+	DDRC_dtype_b		= 13,
+	DDRC_dtype_m		= 0x0000e000,
+	DDRC_rfc_b		= 16,
+	DDRC_rfc_m		= 0x000f0000,
+	DDRC_rp_b		= 20,
+	DDRC_rp_m		= 0x00300000,
+	DDRC_ap_b		= 22,
+	DDRC_ap_m		= 0x00400000,
+	DDRC_rcd_b		= 23,
+	DDRC_rcd_m		= 0x01800000,
+	DDRC_cl_b		= 25,
+	DDRC_cl_m		= 0x06000000,
+	DDRC_dbm_b		= 27,
+	DDRC_dbm_m		= 0x08000000,
+	DDRC_sds_b		= 28,
+	DDRC_sds_m		= 0x10000000,
+	DDRC_atp_b		= 29,
+	DDRC_atp_m		= 0x60000000,
+	DDRC_re_b		= 31,
+	DDRC_re_m		= 0x80000000,
+
+	DDRRDC_ces_b		= 0,
+	DDRRDC_ces_m		= 0x00000001,
+	DDRRDC_ace_b		= 1,
+	DDRRDC_ace_m		= 0x00000002,
+
+	DDRABASE_baseaddr_b	= 16,
+	DDRABASE_baseaddr_m	= 0xffff0000,
+
+	DDRAMASK_mask_b		= 16,
+	DDRAMASK_mask_m		= 0xffff0000,
+
+	DDRAMAP_map_b		= 16,
+	DDRAMAP_map_m		= 0xffff0000,
+
+	DDRCUST_cs_b		= 0,
+	DDRCUST_cs_m		= 0x00000003,
+	DDRCUST_we_b		= 2,
+	DDRCUST_we_m		= 0x00000004,
+	DDRCUST_ras_b		= 3,
+	DDRCUST_ras_m		= 0x00000008,
+	DDRCUST_cas_b		= 4,
+	DDRCUST_cas_m		= 0x00000010,
+	DDRCUST_cke_b		= 5,
+	DDRCUST_cke_m		= 0x00000020,
+	DDRCUST_ba_b		= 6,
+	DDRCUST_ba_m		= 0x000000c0,
+
+	RCOUNT_rcount_b		= 0,
+	RCOUNT_rcount_m		= 0x0000ffff,
+
+	RCOMPARE_rcompare_b	= 0,
+	RCOMPARE_rcompare_m	= 0x0000ffff,
+
+	RTC_ce_b		= 0,
+	RTC_ce_m		= 0x00000001,
+	RTC_to_b		= 1,
+	RTC_to_m		= 0x00000002,
+	RTC_rqe_b		= 2,
+	RTC_rqe_m		= 0x00000004,
+
+	DDRDQSC_dm_b		= 0,
+	DDRDQSC_dm_m		= 0x00000003,
+	DDRDQSC_dqsbs_b		= 2,
+	DDRDQSC_dqsbs_m		= 0x000000fc,
+	DDRDQSC_db_b		= 8,
+	DDRDQSC_db_m		= 0x00000100,
+	DDRDQSC_dbsp_b		= 9,
+	DDRDQSC_dbsp_m		= 0x01fffe00,
+	DDRDQSC_bdp_b		= 25,
+	DDRDQSC_bdp_m		= 0x7e000000,
+
+	DDRDLLC_eao_b		= 0,
+	DDRDLLC_eao_m		= 0x00000001,
+	DDRDLLC_eo_b		= 1,
+	DDRDLLC_eo_m		= 0x0000003e,
+	DDRDLLC_fs_b		= 6,
+	DDRDLLC_fs_m		= 0x000000c0,
+	DDRDLLC_as_b		= 8,
+	DDRDLLC_as_m		= 0x00000700,
+	DDRDLLC_sp_b		= 11,
+	DDRDLLC_sp_m		= 0x001ff800,
+
+	DDRDLLFC_men_b		= 0,
+	DDRDLLFC_men_m		= 0x00000001,
+	DDRDLLFC_aen_b		= 1,
+	DDRDLLFC_aen_m		= 0x00000002,
+	DDRDLLFC_ff_b		= 2,
+	DDRDLLFC_ff_m		= 0x00000004,
+
+	DDRDLLTA_addr_b		= 2,
+	DDRDLLTA_addr_m		= 0xfffffffc,
+
+	DDRDLLED_dbe_b		= 0,
+	DDRDLLED_dbe_m		= 0x00000001,
+	DDRDLLED_dte_b		= 1,
+	DDRDLLED_dte_m		= 0x00000002,
+	
+		
+} ;
+
+#endif	// __IDT_DDR_H__
diff -urN linux.old/include/asm-mips/rc32434/dma.h linux.dev/include/asm-mips/rc32434/dma.h
--- linux.old/include/asm-mips/rc32434/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/dma.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,168 @@
+#ifndef __IDT_DMA_H__
+#define __IDT_DMA_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * DMA register definition.
+ *
+ * File   : $Id: dma.h,v 1.3 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: dma.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:03  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:30:46  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:21  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+enum
+{
+	DMA0_PhysicalAddress	= 0x18040000,
+	DMA_PhysicalAddress	= DMA0_PhysicalAddress,		// Default
+
+	DMA0_VirtualAddress	= 0xb8040000,
+	DMA_VirtualAddress	= DMA0_VirtualAddress,		// Default
+} ;
+
+/*
+ * DMA descriptor (in physical memory).
+ */
+
+typedef struct DMAD_s
+{
+	u32			control ;	// Control. use DMAD_*
+	u32			ca ;		// Current Address.
+	u32			devcs ; 	// Device control and status.
+	u32			link ;		// Next descriptor in chain.
+} volatile *DMAD_t ;
+
+enum
+{
+	DMAD_size		= sizeof (struct DMAD_s),
+	DMAD_count_b		= 0,		// in DMAD_t -> control
+	DMAD_count_m		= 0x0003ffff,	// in DMAD_t -> control
+	DMAD_ds_b		= 20,		// in DMAD_t -> control
+	DMAD_ds_m		= 0x00300000,	// in DMAD_t -> control
+		DMAD_ds_ethRcv_v	= 0,
+		DMAD_ds_ethXmt_v	= 0,
+		DMAD_ds_memToFifo_v	= 0,
+		DMAD_ds_fifoToMem_v	= 0,
+		DMAD_ds_pciToMem_v	= 0,
+		DMAD_ds_memToPci_v	= 0,
+	
+	DMAD_devcmd_b		= 22,		// in DMAD_t -> control
+	DMAD_devcmd_m		= 0x01c00000,	// in DMAD_t -> control
+		DMAD_devcmd_byte_v	= 0,	//memory-to-memory
+		DMAD_devcmd_halfword_v	= 1,	//memory-to-memory
+		DMAD_devcmd_word_v	= 2,	//memory-to-memory
+		DMAD_devcmd_2words_v	= 3,	//memory-to-memory
+		DMAD_devcmd_4words_v	= 4,	//memory-to-memory
+		DMAD_devcmd_6words_v	= 5,	//memory-to-memory
+		DMAD_devcmd_8words_v	= 6,	//memory-to-memory
+		DMAD_devcmd_16words_v	= 7,	//memory-to-memory
+	DMAD_cof_b		= 25,		// chain on finished
+	DMAD_cof_m		= 0x02000000,	// 
+	DMAD_cod_b		= 26,		// chain on done
+	DMAD_cod_m		= 0x04000000,	// 
+	DMAD_iof_b		= 27,		// interrupt on finished
+	DMAD_iof_m		= 0x08000000,	// 
+	DMAD_iod_b		= 28,		// interrupt on done
+	DMAD_iod_m		= 0x10000000,	// 
+	DMAD_t_b		= 29,		// terminated
+	DMAD_t_m		= 0x20000000,	// 
+	DMAD_d_b		= 30,		// done
+	DMAD_d_m		= 0x40000000,	// 
+	DMAD_f_b		= 31,		// finished
+	DMAD_f_m		= 0x80000000,	// 
+} ;
+
+/*
+ * DMA register (within Internal Register Map).
+ */
+
+struct DMA_Chan_s
+{
+	u32		dmac ;		// Control.
+	u32		dmas ;		// Status.	
+	u32		dmasm ; 	// Mask.
+	u32		dmadptr ;	// Descriptor pointer.
+	u32		dmandptr ;	// Next descriptor pointer.
+};
+
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;
+
+//DMA_Channels	  use DMACH_count instead
+
+enum
+{
+	DMAC_run_b	= 0,		// 
+	DMAC_run_m	= 0x00000001,	// 
+	DMAC_dm_b	= 1,		// done mask
+	DMAC_dm_m	= 0x00000002,	// 
+	DMAC_mode_b	= 2,		// 
+	DMAC_mode_m	= 0x0000000c,	// 
+		DMAC_mode_auto_v	= 0,
+		DMAC_mode_burst_v	= 1,
+		DMAC_mode_transfer_v	= 2, //usually used
+		DMAC_mode_reserved_v	= 3,
+	DMAC_a_b	= 4,		// 
+	DMAC_a_m	= 0x00000010,	// 
+
+	DMAS_f_b	= 0,		// finished (sticky) 
+	DMAS_f_m	= 0x00000001,	//		     
+	DMAS_d_b	= 1,		// done (sticky)     
+	DMAS_d_m	= 0x00000002,	//		     
+	DMAS_c_b	= 2,		// chain (sticky)    
+	DMAS_c_m	= 0x00000004,	//		     
+	DMAS_e_b	= 3,		// error (sticky)    
+	DMAS_e_m	= 0x00000008,	//		     
+	DMAS_h_b	= 4,		// halt (sticky)     
+	DMAS_h_m	= 0x00000010,	//		     
+
+	DMASM_f_b	= 0,		// finished (1=mask)
+	DMASM_f_m	= 0x00000001,	// 
+	DMASM_d_b	= 1,		// done (1=mask)
+	DMASM_d_m	= 0x00000002,	// 
+	DMASM_c_b	= 2,		// chain (1=mask)
+	DMASM_c_m	= 0x00000004,	// 
+	DMASM_e_b	= 3,		// error (1=mask)
+	DMASM_e_m	= 0x00000008,	// 
+	DMASM_h_b	= 4,		// halt (1=mask)
+	DMASM_h_m	= 0x00000010,	// 
+} ;
+
+/*
+ * DMA channel definitions
+ */
+
+enum
+{
+	DMACH_ethRcv = 0,
+	DMACH_ethXmt = 1,
+	DMACH_memToFifo = 2,
+	DMACH_fifoToMem = 3,
+	DMACH_pciToMem = 4,
+	DMACH_memToPci = 5,
+	
+	DMACH_count //must be last
+};
+
+
+typedef struct DMAC_s
+{
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]
+} volatile *DMA_t ;
+
+#endif	// __IDT_DMA_H__
+
diff -urN linux.old/include/asm-mips/rc32434/dma_v.h linux.dev/include/asm-mips/rc32434/dma_v.h
--- linux.old/include/asm-mips/rc32434/dma_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/dma_v.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,72 @@
+#ifndef __IDT_DMA_V_H__
+#define __IDT_DMA_V_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * DMA register definition.
+ *
+ * File   : $Id: dma.h,v 1.3 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: dma.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:03  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:30:46  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:21  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+#include  <asm/rc32434/dma.h> 
+#include  <asm/rc32434/rc32434.h>
+#define DMA_CHAN_OFFSET  0x14
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) != 0)
+#define DMA_COUNT(count)   \
+  ((count) & DMAD_count_m)
+
+#define DMA_HALT_TIMEOUT 500
+
+
+static inline int rc32434_halt_dma(DMA_Chan_t ch)
+{
+	int timeout=1;
+	if (local_readl(&ch->dmac) & DMAC_run_m) {
+		local_writel(0, &ch->dmac); 
+		for (timeout = DMA_HALT_TIMEOUT; timeout > 0; timeout--) {
+			if (local_readl(&ch->dmas) & DMAS_h_m) {
+				local_writel(0, &ch->dmas);  
+				break;
+			}
+		}
+	}
+
+	return timeout ? 0 : 1;
+}
+
+static inline void rc32434_start_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	local_writel(0, &ch->dmandptr); 
+	local_writel(dma_addr, &ch->dmadptr);
+}
+
+static inline void rc32434_chain_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	local_writel(dma_addr, &ch->dmandptr);
+}
+
+#endif	// __IDT_DMA_V_H__
+
+
+
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/eth.h linux.dev/include/asm-mips/rc32434/eth.h
--- linux.old/include/asm-mips/rc32434/eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/eth.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,320 @@
+#ifndef	__IDT_ETH_H__
+#define	__IDT_ETH_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Ethernet register definition.
+ *
+ * File   : $Id: eth.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020605
+ * Update :
+ *	    $Log: eth.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:19:46  astichte
+ *	    Added
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+enum
+{
+	ETH0_PhysicalAddress	= 0x18060000,
+	ETH_PhysicalAddress	= ETH0_PhysicalAddress,		// Default
+
+	ETH0_VirtualAddress	= 0xb8060000,
+	ETH_VirtualAddress	= ETH0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	u32 ethintfc		;
+	u32 ethfifott		;
+	u32 etharc		;
+	u32 ethhash0		;
+	u32 ethhash1		;
+	u32 ethu0 [4]		;	// Reserved.	
+	u32 ethpfs		;
+	u32 ethmcp		;
+	u32 eth_u1 [10]		;	// Reserved.
+	u32 ethspare		;
+	u32 eth_u2 [42]		;	// Reserved. 
+	u32 ethsal0		;
+	u32 ethsah0		;
+	u32 ethsal1		;
+	u32 ethsah1		;
+	u32 ethsal2		;
+	u32 ethsah2		;
+	u32 ethsal3		;
+	u32 ethsah3		;
+	u32 ethrbc		;
+	u32 ethrpc		;
+	u32 ethrupc		;
+	u32 ethrfc		;
+	u32 ethtbc		;
+	u32 ethgpf		;
+	u32 eth_u9 [50]		;	// Reserved.	
+	u32 ethmac1		;
+	u32 ethmac2		;
+	u32 ethipgt		;
+	u32 ethipgr		;
+	u32 ethclrt		;
+	u32 ethmaxf		;
+	u32 eth_u10		;	// Reserved.	
+	u32 ethmtest		;
+	u32 miimcfg		;
+	u32 miimcmd		;
+	u32 miimaddr		;
+	u32 miimwtd		;
+	u32 miimrdd		;
+	u32 miimind		;
+	u32 eth_u11		;	// Reserved.
+	u32 eth_u12		;	// Reserved.
+	u32 ethcfsa0		;
+	u32 ethcfsa1		;
+	u32 ethcfsa2		;
+} volatile *ETH_t;
+
+enum
+{
+	ETHINTFC_en_b		= 0,
+	ETHINTFC_en_m		= 0x00000001,
+	ETHINTFC_its_b		= 1,
+	ETHINTFC_its_m		= 0x00000002,
+	ETHINTFC_rip_b		= 2,
+	ETHINTFC_rip_m		= 0x00000004,
+	ETHINTFC_jam_b		= 3,
+	ETHINTFC_jam_m		= 0x00000008,
+	ETHINTFC_ovr_b		= 4,
+	ETHINTFC_ovr_m		= 0x00000010,
+	ETHINTFC_und_b		= 5,
+	ETHINTFC_und_m		= 0x00000020,
+	ETHINTFC_iom_b 		= 6,
+	ETHINTFC_iom_m		= 0x000000c0,
+
+	ETHFIFOTT_tth_b		= 0,
+	ETHFIFOTT_tth_m		= 0x0000007f,
+
+	ETHARC_pro_b		= 0,
+	ETHARC_pro_m		= 0x00000001,
+	ETHARC_am_b		= 1,
+	ETHARC_am_m		= 0x00000002,
+	ETHARC_afm_b		= 2,
+	ETHARC_afm_m		= 0x00000004,
+	ETHARC_ab_b		= 3,
+	ETHARC_ab_m		= 0x00000008,
+
+	ETHSAL_byte5_b		= 0,
+	ETHSAL_byte5_m		= 0x000000ff,
+	ETHSAL_byte4_b		= 8,
+	ETHSAL_byte4_m		= 0x0000ff00,
+	ETHSAL_byte3_b		= 16,
+	ETHSAL_byte3_m		= 0x00ff0000,
+	ETHSAL_byte2_b		= 24,
+	ETHSAL_byte2_m		= 0xff000000,
+
+	ETHSAH_byte1_b		= 0,
+	ETHSAH_byte1_m		= 0x000000ff,
+	ETHSAH_byte0_b		= 8,
+	ETHSAH_byte0_m		= 0x0000ff00,
+	
+	ETHGPF_ptv_b		= 0,
+	ETHGPF_ptv_m		= 0x0000ffff,
+
+	ETHPFS_pfd_b		= 0,
+	ETHPFS_pfd_m		= 0x00000001,
+
+	ETHCFSA0_cfsa4_b	= 0,
+	ETHCFSA0_cfsa4_m	= 0x000000ff,
+	ETHCFSA0_cfsa5_b	= 8,
+	ETHCFSA0_cfsa5_m	= 0x0000ff00,
+
+	ETHCFSA1_cfsa2_b	= 0,
+	ETHCFSA1_cfsa2_m	= 0x000000ff,
+	ETHCFSA1_cfsa3_b	= 8,
+	ETHCFSA1_cfsa3_m	= 0x0000ff00,
+
+	ETHCFSA2_cfsa0_b	= 0,
+	ETHCFSA2_cfsa0_m	= 0x000000ff,
+	ETHCFSA2_cfsa1_b	= 8,
+	ETHCFSA2_cfsa1_m	= 0x0000ff00,
+
+	ETHMAC1_re_b		= 0,
+	ETHMAC1_re_m		= 0x00000001,
+	ETHMAC1_paf_b		= 1,
+	ETHMAC1_paf_m		= 0x00000002,
+	ETHMAC1_rfc_b		= 2,
+	ETHMAC1_rfc_m		= 0x00000004,
+	ETHMAC1_tfc_b		= 3,
+	ETHMAC1_tfc_m		= 0x00000008,
+	ETHMAC1_lb_b		= 4,
+	ETHMAC1_lb_m		= 0x00000010,
+	ETHMAC1_mr_b		= 31,
+	ETHMAC1_mr_m		= 0x80000000,
+
+	ETHMAC2_fd_b		= 0,
+	ETHMAC2_fd_m		= 0x00000001,
+	ETHMAC2_flc_b		= 1,
+	ETHMAC2_flc_m		= 0x00000002,
+	ETHMAC2_hfe_b		= 2,
+	ETHMAC2_hfe_m		= 0x00000004,
+	ETHMAC2_dc_b		= 3,
+	ETHMAC2_dc_m		= 0x00000008,
+	ETHMAC2_cen_b		= 4,
+	ETHMAC2_cen_m		= 0x00000010,
+	ETHMAC2_pe_b		= 5,
+	ETHMAC2_pe_m		= 0x00000020,
+	ETHMAC2_vpe_b		= 6,
+	ETHMAC2_vpe_m		= 0x00000040,
+	ETHMAC2_ape_b		= 7,
+	ETHMAC2_ape_m		= 0x00000080,
+	ETHMAC2_ppe_b		= 8,
+	ETHMAC2_ppe_m		= 0x00000100,
+	ETHMAC2_lpe_b		= 9,
+	ETHMAC2_lpe_m		= 0x00000200,
+	ETHMAC2_nb_b		= 12,
+	ETHMAC2_nb_m		= 0x00001000,
+	ETHMAC2_bp_b		= 13,
+	ETHMAC2_bp_m		= 0x00002000,
+	ETHMAC2_ed_b		= 14,
+	ETHMAC2_ed_m		= 0x00004000,
+
+	ETHIPGT_ipgt_b		= 0,
+	ETHIPGT_ipgt_m		= 0x0000007f,
+
+	ETHIPGR_ipgr2_b		= 0,
+	ETHIPGR_ipgr2_m		= 0x0000007f,
+	ETHIPGR_ipgr1_b		= 8,
+	ETHIPGR_ipgr1_m		= 0x00007f00,
+
+	ETHCLRT_maxret_b	= 0,
+	ETHCLRT_maxret_m	= 0x0000000f,
+	ETHCLRT_colwin_b	= 8,
+	ETHCLRT_colwin_m	= 0x00003f00,
+
+	ETHMAXF_maxf_b		= 0,
+	ETHMAXF_maxf_m		= 0x0000ffff,
+
+	ETHMTEST_tb_b		= 2,
+	ETHMTEST_tb_m		= 0x00000004,
+
+	ETHMCP_div_b		= 0,
+	ETHMCP_div_m		= 0x000000ff,
+	
+	MIIMCFG_rsv_b		= 0,
+	MIIMCFG_rsv_m		= 0x0000000c,
+
+	MIIMCMD_rd_b		= 0,
+	MIIMCMD_rd_m		= 0x00000001,
+	MIIMCMD_scn_b		= 1,
+	MIIMCMD_scn_m		= 0x00000002,
+
+	MIIMADDR_regaddr_b	= 0,
+	MIIMADDR_regaddr_m	= 0x0000001f,
+	MIIMADDR_phyaddr_b	= 8,
+	MIIMADDR_phyaddr_m	= 0x00001f00,
+
+	MIIMWTD_wdata_b		= 0,
+	MIIMWTD_wdata_m		= 0x0000ffff,
+
+	MIIMRDD_rdata_b		= 0,
+	MIIMRDD_rdata_m		= 0x0000ffff,
+
+	MIIMIND_bsy_b		= 0,
+	MIIMIND_bsy_m		= 0x00000001,
+	MIIMIND_scn_b		= 1,
+	MIIMIND_scn_m		= 0x00000002,
+	MIIMIND_nv_b		= 2,
+	MIIMIND_nv_m		= 0x00000004,
+
+} ;
+
+/*
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx descriptors.
+ */
+enum
+{
+	ETHRX_fd_b		= 0,
+	ETHRX_fd_m		= 0x00000001,
+	ETHRX_ld_b		= 1,
+	ETHRX_ld_m		= 0x00000002,
+	ETHRX_rok_b		= 2,
+	ETHRX_rok_m		= 0x00000004,
+	ETHRX_fm_b		= 3,
+	ETHRX_fm_m		= 0x00000008,
+	ETHRX_mp_b		= 4,
+	ETHRX_mp_m		= 0x00000010,
+	ETHRX_bp_b		= 5,
+	ETHRX_bp_m		= 0x00000020,
+	ETHRX_vlt_b		= 6,
+	ETHRX_vlt_m		= 0x00000040,
+	ETHRX_cf_b		= 7,
+	ETHRX_cf_m		= 0x00000080,
+	ETHRX_ovr_b		= 8,
+	ETHRX_ovr_m		= 0x00000100,
+	ETHRX_crc_b		= 9,
+	ETHRX_crc_m		= 0x00000200,
+	ETHRX_cv_b		= 10,
+	ETHRX_cv_m		= 0x00000400,
+	ETHRX_db_b		= 11,
+	ETHRX_db_m		= 0x00000800,
+	ETHRX_le_b		= 12,
+	ETHRX_le_m		= 0x00001000,
+	ETHRX_lor_b		= 13,
+	ETHRX_lor_m		= 0x00002000,
+	ETHRX_ces_b		= 14,
+	ETHRX_ces_m		= 0x00004000,
+	ETHRX_length_b		= 16,
+	ETHRX_length_m		= 0xffff0000,
+
+	ETHTX_fd_b		= 0,
+	ETHTX_fd_m		= 0x00000001,
+	ETHTX_ld_b		= 1,
+	ETHTX_ld_m		= 0x00000002,
+	ETHTX_oen_b		= 2,
+	ETHTX_oen_m		= 0x00000004,
+	ETHTX_pen_b		= 3,
+	ETHTX_pen_m		= 0x00000008,
+	ETHTX_cen_b		= 4,
+	ETHTX_cen_m		= 0x00000010,
+	ETHTX_hen_b		= 5,
+	ETHTX_hen_m		= 0x00000020,
+	ETHTX_tok_b		= 6,
+	ETHTX_tok_m		= 0x00000040,
+	ETHTX_mp_b		= 7,
+	ETHTX_mp_m		= 0x00000080,
+	ETHTX_bp_b		= 8,
+	ETHTX_bp_m		= 0x00000100,
+	ETHTX_und_b		= 9,
+	ETHTX_und_m		= 0x00000200,
+	ETHTX_of_b		= 10,
+	ETHTX_of_m		= 0x00000400,
+	ETHTX_ed_b		= 11,
+	ETHTX_ed_m		= 0x00000800,
+	ETHTX_ec_b		= 12,
+	ETHTX_ec_m		= 0x00001000,
+	ETHTX_lc_b		= 13,
+	ETHTX_lc_m		= 0x00002000,
+	ETHTX_td_b		= 14,
+	ETHTX_td_m		= 0x00004000,
+	ETHTX_crc_b		= 15,
+	ETHTX_crc_m		= 0x00008000,
+	ETHTX_le_b		= 16,
+	ETHTX_le_m		= 0x00010000,
+	ETHTX_cc_b		= 17,
+	ETHTX_cc_m		= 0x001E0000,
+} ;
+
+#endif	// __IDT_ETH_H__
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/eth_v.h linux.dev/include/asm-mips/rc32434/eth_v.h
--- linux.old/include/asm-mips/rc32434/eth_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/eth_v.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,63 @@
+#ifndef	__IDT_ETH_V_H__
+#define	__IDT_ETH_V_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Ethernet register definition.
+ *
+ * File   : $Id: eth.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020605
+ * Update :
+ *	    $Log: eth.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:19:46  astichte
+ *	    Added
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/eth.h> 
+
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b )   /* Transmit Okay    */
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b )    /* Multicast        */
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b )    /* Broadcast        */
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b )   /* Transmit FIFO Underflow */
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b )    /* Oversized frame  */
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b )    /* Excessive deferral  */
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)     /* Excessive collisions  */
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b )    /* Late Collision   */
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b )    /* Transmit deferred*/
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b )   /* CRC Error        */
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b )    /* Length Error     */
+
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* Collision Count  */
+
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b)    /* Receive Okay     */
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)     /* Is Filter Match  */
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)     /* Is it MP         */
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)     /* Is it BP         */
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b)    /* VLAN Tag Detect  */
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)     /* Control Frame    */
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b)    /* Receive Overflow */
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b)    /* CRC Error        */
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)     /* Code Violation   */
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)     /* Dribble Bits     */
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)     /* Length error     */
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b)    /* Length Out of Range */
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b)  /* Preamble error   */
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> ETHRX_length_b)   /* Length of the received packet */
+#endif	// __IDT_ETH_V_H__
+
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/gpio.h linux.dev/include/asm-mips/rc32434/gpio.h
--- linux.old/include/asm-mips/rc32434/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/gpio.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,181 @@
+#ifndef __IDT_GPIO_H__
+#define __IDT_GPIO_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * GPIO register definition.
+ *
+ * File   : $Id: gpio.h,v 1.2 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: gpio.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+enum
+{
+	GPIO0_PhysicalAddress	= 0x18050000,
+	GPIO_PhysicalAddress	= GPIO0_PhysicalAddress,	// Default
+
+	GPIO0_VirtualAddress	= 0xb8050000,
+	GPIO_VirtualAddress	= GPIO0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	u32   gpiofunc;   /* GPIO Function Register
+			   * gpiofunc[x]==0 bit = gpio
+			   * func[x]==1  bit = altfunc
+			   */
+	u32   gpiocfg;	  /* GPIO Configuration Register
+			   * gpiocfg[x]==0 bit = input
+			   * gpiocfg[x]==1 bit = output
+			   */
+	u32   gpiod;	  /* GPIO Data Register
+			   * gpiod[x] read/write gpio pinX status
+			   */
+	u32   gpioilevel; /* GPIO Interrupt Status Register
+			   * interrupt level (see gpioistat)
+			   */
+	u32   gpioistat;  /* Gpio Interrupt Status Register
+			   * istat[x] = (gpiod[x] == level[x])
+			   * cleared in ISR (STICKY bits)
+			   */
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register */
+} volatile * GPIO_t ;
+
+typedef enum
+{
+	GPIO_gpio_v		= 0,		// gpiofunc use pin as GPIO.
+	GPIO_alt_v		= 1,		// gpiofunc use pin as alt.
+	GPIO_input_v		= 0,		// gpiocfg use pin as input.
+	GPIO_output_v		= 1,		// gpiocfg use pin as output.
+	GPIO_pin0_b		= 0,
+	GPIO_pin0_m		= 0x00000001,
+	GPIO_pin1_b		= 1,
+	GPIO_pin1_m		= 0x00000002,
+	GPIO_pin2_b		= 2,
+	GPIO_pin2_m		= 0x00000004,
+	GPIO_pin3_b		= 3,
+	GPIO_pin3_m		= 0x00000008,
+	GPIO_pin4_b		= 4,
+	GPIO_pin4_m		= 0x00000010,
+	GPIO_pin5_b		= 5,
+	GPIO_pin5_m		= 0x00000020,
+	GPIO_pin6_b		= 6,
+	GPIO_pin6_m		= 0x00000040,
+	GPIO_pin7_b		= 7,
+	GPIO_pin7_m		= 0x00000080,
+	GPIO_pin8_b		= 8,
+	GPIO_pin8_m		= 0x00000100,
+	GPIO_pin9_b		= 9,
+	GPIO_pin9_m		= 0x00000200,
+	GPIO_pin10_b		= 10,
+	GPIO_pin10_m		= 0x00000400,
+	GPIO_pin11_b		= 11,
+	GPIO_pin11_m		= 0x00000800,
+	GPIO_pin12_b		= 12,
+	GPIO_pin12_m		= 0x00001000,
+	GPIO_pin13_b		= 13,
+	GPIO_pin13_m		= 0x00002000,
+	GPIO_pin14_b		= 14,
+	GPIO_pin14_m		= 0x00004000,
+	GPIO_pin15_b		= 15,
+	GPIO_pin15_m		= 0x00008000,
+	GPIO_pin16_b		= 16,
+	GPIO_pin16_m		= 0x00010000,
+	GPIO_pin17_b		= 17,
+	GPIO_pin17_m		= 0x00020000,
+	GPIO_pin18_b		= 18,
+	GPIO_pin18_m		= 0x00040000,
+	GPIO_pin19_b		= 19,
+	GPIO_pin19_m		= 0x00080000,
+	GPIO_pin20_b		= 20,
+	GPIO_pin20_m		= 0x00100000,
+	GPIO_pin21_b		= 21,
+	GPIO_pin21_m		= 0x00200000,
+	GPIO_pin22_b		= 22,
+	GPIO_pin22_m		= 0x00400000,
+	GPIO_pin23_b		= 23,
+	GPIO_pin23_m		= 0x00800000,
+	GPIO_pin24_b		= 24,
+	GPIO_pin24_m		= 0x01000000,
+	GPIO_pin25_b		= 25,
+	GPIO_pin25_m		= 0x02000000,
+	GPIO_pin26_b		= 26,
+	GPIO_pin26_m		= 0x04000000,
+	GPIO_pin27_b		= 27,
+	GPIO_pin27_m		= 0x08000000,
+	GPIO_pin28_b		= 28,
+	GPIO_pin28_m		= 0x10000000,
+	GPIO_pin29_b		= 29,
+	GPIO_pin29_m		= 0x20000000,
+	GPIO_pin30_b		= 30,
+	GPIO_pin30_m		= 0x40000000,
+	GPIO_pin31_b		= 31,
+	GPIO_pin31_m		= 0x80000000,
+
+// Alternate function pins.  Corrsponding gpiofunc bit set to GPIO_alt_v.
+
+	GPIO_u0sout_b		= GPIO_pin0_b,		// UART 0 serial out.
+	GPIO_u0sout_m		= GPIO_pin0_m,
+		GPIO_u0sout_cfg_v	= GPIO_output_v,
+	GPIO_u0sinp_b	= GPIO_pin1_b,			// UART 0 serial in.
+	GPIO_u0sinp_m	= GPIO_pin1_m,
+		GPIO_u0sinp_cfg_v	= GPIO_input_v,
+	GPIO_u0rtsn_b	= GPIO_pin2_b,			// UART 0 req. to send.
+	GPIO_u0rtsn_m	= GPIO_pin2_m,
+		GPIO_u0rtsn_cfg_v	= GPIO_output_v,
+	GPIO_u0ctsn_b	= GPIO_pin3_b,			// UART 0 clear to send.
+	GPIO_u0ctsn_m	= GPIO_pin3_m,
+		GPIO_u0ctsn_cfg_v	= GPIO_input_v,
+	GPIO_maddr22_b		= GPIO_pin4_b, 	// M&P bus bit 22.
+	GPIO_maddr22_m		= GPIO_pin4_m,
+		GPIO_maddr22_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr23_b		= GPIO_pin5_b, 	// M&P bus bit 23.
+	GPIO_maddr23_m		= GPIO_pin5_m,
+		GPIO_maddr23_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr24_b		= GPIO_pin6_b, 	// M&P bus bit 24.
+	GPIO_maddr24_m		= GPIO_pin6_m,
+		GPIO_maddr24_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr25_b		= GPIO_pin7_b, 	// M&P bus bit 25.
+	GPIO_maddr25_m		= GPIO_pin7_m,
+		GPIO_maddr25_cfg_v	= GPIO_output_v,
+
+	GPIO_cpu_b		= GPIO_pin8_b, 	// M&P bus bit 25.
+	GPIO_cpu_m		= GPIO_pin8_m,
+		GPIO_cpu_cfg_v	= GPIO_output_v,
+	GPIO_afspare6_b 	= GPIO_pin9_b, 	// reserved.
+	GPIO_afspare6_m 	= GPIO_pin9_m,
+		GPIO_afspare6_cfg_v	= GPIO_input_v,
+	GPIO_afspare4_b 	= GPIO_pin10_b, 	// reserved.
+	GPIO_afspare4_m 	= GPIO_pin10_m,
+		GPIO_afspare4_cfg_v	= GPIO_input_v,
+	GPIO_afspare3_b 	= GPIO_pin11_b, 	// reserved.
+	GPIO_afspare3_m 	= GPIO_pin11_m,
+		GPIO_afspare3_cfg_v	= GPIO_input_v,
+	GPIO_afspare2_b 	= GPIO_pin12_b, 	// reserved.
+	GPIO_afspare2_m 	= GPIO_pin12_m,
+		GPIO_afspare2_cfg_v	= GPIO_input_v,
+	GPIO_pcimuintn_b	= GPIO_pin13_b, 	// PCI messaging int.
+	GPIO_pcimuintn_m	= GPIO_pin13_m,
+		GPIO_pcimuintn_cfg_v	= GPIO_output_v,
+
+} GPIO_DEFS_t;
+
+#endif	// __IDT_GPIO_H__
+
diff -urN linux.old/include/asm-mips/rc32434/irq.h linux.dev/include/asm-mips/rc32434/irq.h
--- linux.old/include/asm-mips/rc32434/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/irq.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+#include <linux/autoconf.h>
+
+#define NR_IRQS	256
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
diff -urN linux.old/include/asm-mips/rc32434/pci.h linux.dev/include/asm-mips/rc32434/pci.h
--- linux.old/include/asm-mips/rc32434/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/pci.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,692 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   PCI register definitio
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_PCI_H__
+#define __IDT_PCI_H__
+
+enum
+{
+	PCI0_PhysicalAddress	= 0x18080000,
+	PCI_PhysicalAddress	= PCI0_PhysicalAddress,
+
+	PCI0_VirtualAddress	= 0xB8080000,
+	PCI_VirtualAddress	= PCI0_VirtualAddress,
+} ;
+
+enum
+{
+	PCI_LbaCount	= 4,		// Local base addresses.
+} ;
+
+typedef struct
+{
+	u32	a ;		// Address.
+	u32	c ;		// Control.
+	u32	m ;		// mapping.
+} PCI_Map_s ;
+
+typedef struct
+{
+	u32		pcic ;
+	u32		pcis ;
+	u32		pcism ;
+	u32		pcicfga ;
+	u32		pcicfgd ;
+	PCI_Map_s	pcilba [PCI_LbaCount] ;
+	u32		pcidac ;
+	u32		pcidas ;
+	u32		pcidasm ;
+	u32		pcidad ;
+	u32		pcidma8c ;
+	u32		pcidma9c ;
+	u32		pcitc ;
+} volatile *PCI_t ;
+
+// PCI messaging unit.
+enum
+{
+	PCIM_Count	= 2,
+} ;
+typedef struct
+{
+	u32		pciim [PCIM_Count] ;
+	u32		pciom [PCIM_Count] ;
+	u32		pciid ;
+	u32		pciiic ;
+	u32		pciiim ;
+	u32		pciiod ;
+	u32		pciioic ;
+	u32		pciioim ;
+} volatile *PCIM_t ;
+
+/*******************************************************************************
+ *
+ * PCI Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIC_en_b	= 0,
+	PCIC_en_m	= 0x00000001,
+	PCIC_tnr_b	= 1,
+	PCIC_tnr_m	= 0x00000002,
+	PCIC_sce_b	= 2,
+	PCIC_sce_m	= 0x00000004,
+	PCIC_ien_b	= 3,
+	PCIC_ien_m	= 0x00000008,
+	PCIC_aaa_b	= 4,
+	PCIC_aaa_m	= 0x00000010,
+	PCIC_eap_b	= 5,
+	PCIC_eap_m	= 0x00000020,
+	PCIC_pcim_b	= 6,
+	PCIC_pcim_m	= 0x000001c0,
+		PCIC_pcim_disabled_v	= 0,
+		PCIC_pcim_tnr_v 	= 1,	// Satellite - target not ready
+		PCIC_pcim_suspend_v	= 2,	// Satellite - suspended CPU.
+		PCIC_pcim_extern_v	= 3,	// Host - external arbiter.
+		PCIC_pcim_fixed_v	= 4,	// Host - fixed priority arb.
+		PCIC_pcim_roundrobin_v	= 5,	// Host - round robin priority.
+		PCIC_pcim_reserved6_v	= 6,
+		PCIC_pcim_reserved7_v	= 7,
+	PCIC_igm_b	= 9,
+	PCIC_igm_m	= 0x00000200,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIS_eed_b	= 0,
+	PCIS_eed_m	= 0x00000001,
+	PCIS_wr_b	= 1,
+	PCIS_wr_m	= 0x00000002,
+	PCIS_nmi_b	= 2,
+	PCIS_nmi_m	= 0x00000004,
+	PCIS_ii_b	= 3,
+	PCIS_ii_m	= 0x00000008,
+	PCIS_cwe_b	= 4,
+	PCIS_cwe_m	= 0x00000010,
+	PCIS_cre_b	= 5,
+	PCIS_cre_m	= 0x00000020,
+	PCIS_mdpe_b	= 6,
+	PCIS_mdpe_m	= 0x00000040,
+	PCIS_sta_b	= 7,
+	PCIS_sta_m	= 0x00000080,
+	PCIS_rta_b	= 8,
+	PCIS_rta_m	= 0x00000100,
+	PCIS_rma_b	= 9,
+	PCIS_rma_m	= 0x00000200,
+	PCIS_sse_b	= 10,
+	PCIS_sse_m	= 0x00000400,
+	PCIS_ose_b	= 11,
+	PCIS_ose_m	= 0x00000800,
+	PCIS_pe_b	= 12,
+	PCIS_pe_m	= 0x00001000,
+	PCIS_tae_b	= 13,
+	PCIS_tae_m	= 0x00002000,
+	PCIS_rle_b	= 14,
+	PCIS_rle_m	= 0x00004000,
+	PCIS_bme_b	= 15,
+	PCIS_bme_m	= 0x00008000,
+	PCIS_prd_b	= 16,
+	PCIS_prd_m	= 0x00010000,
+	PCIS_rip_b	= 17,
+	PCIS_rip_m	= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Mask Register
+ *
+ ******************************************************************************/
+enum {
+	PCISM_eed_b		= 0,
+	PCISM_eed_m		= 0x00000001,
+	PCISM_wr_b		= 1,
+	PCISM_wr_m		= 0x00000002,
+	PCISM_nmi_b		= 2,
+	PCISM_nmi_m		= 0x00000004,
+	PCISM_ii_b		= 3,
+	PCISM_ii_m		= 0x00000008,
+	PCISM_cwe_b		= 4,
+	PCISM_cwe_m		= 0x00000010,
+	PCISM_cre_b		= 5,
+	PCISM_cre_m		= 0x00000020,
+	PCISM_mdpe_b		= 6,
+	PCISM_mdpe_m		= 0x00000040,
+	PCISM_sta_b		= 7,
+	PCISM_sta_m		= 0x00000080,
+	PCISM_rta_b		= 8,
+	PCISM_rta_m		= 0x00000100,
+	PCISM_rma_b		= 9,
+	PCISM_rma_m		= 0x00000200,
+	PCISM_sse_b		= 10,
+	PCISM_sse_m		= 0x00000400,
+	PCISM_ose_b		= 11,
+	PCISM_ose_m		= 0x00000800,
+	PCISM_pe_b		= 12,
+	PCISM_pe_m		= 0x00001000,
+	PCISM_tae_b		= 13,
+	PCISM_tae_m		= 0x00002000,
+	PCISM_rle_b		= 14,
+	PCISM_rle_m		= 0x00004000,
+	PCISM_bme_b		= 15,
+	PCISM_bme_m		= 0x00008000,
+	PCISM_prd_b		= 16,
+	PCISM_prd_m		= 0x00010000,
+	PCISM_rip_b		= 17,
+	PCISM_rip_m		= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Configuration Address Register
+ *
+ ******************************************************************************/
+enum {
+	PCICFGA_reg_b		= 2,
+	PCICFGA_reg_m		= 0x000000fc,
+		PCICFGA_reg_id_v	= 0x00>>2, //use PCFGID_
+		PCICFGA_reg_04_v	= 0x04>>2, //use PCFG04_
+		PCICFGA_reg_08_v	= 0x08>>2, //use PCFG08_
+		PCICFGA_reg_0C_v	= 0x0C>>2, //use PCFG0C_
+		PCICFGA_reg_pba0_v	= 0x10>>2, //use PCIPBA_
+		PCICFGA_reg_pba1_v	= 0x14>>2, //use PCIPBA_
+		PCICFGA_reg_pba2_v	= 0x18>>2, //use PCIPBA_
+		PCICFGA_reg_pba3_v	= 0x1c>>2, //use PCIPBA_
+		PCICFGA_reg_subsystem_v = 0x2c>>2, //use PCFGSS_
+		PCICFGA_reg_3C_v	= 0x3C>>2, //use PCFG3C_
+		PCICFGA_reg_pba0c_v	= 0x44>>2, //use PCIPBAC_
+		PCICFGA_reg_pba0m_v	= 0x48>>2,
+		PCICFGA_reg_pba1c_v	= 0x4c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba1m_v	= 0x50>>2,
+		PCICFGA_reg_pba2c_v	= 0x54>>2, //use PCIPBAC_
+		PCICFGA_reg_pba2m_v	= 0x58>>2,
+		PCICFGA_reg_pba3c_v	= 0x5c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba3m_v	= 0x60>>2,
+		PCICFGA_reg_pmgt_v	= 0x64>>2,
+	PCICFGA_func_b		= 8,
+	PCICFGA_func_m		= 0x00000700,
+	PCICFGA_dev_b		= 11,
+	PCICFGA_dev_m		= 0x0000f800,
+		PCICFGA_dev_internal_v	= 0,
+	PCICFGA_bus_b		= 16,
+	PCICFGA_bus_m		= 0x00ff0000,
+		PCICFGA_bus_type0_v	= 0,	//local bus
+	PCICFGA_en_b		= 31,		// read only
+	PCICFGA_en_m		= 0x80000000,
+} ;
+
+enum {
+	PCFGID_vendor_b 	= 0,
+	PCFGID_vendor_m 	= 0x0000ffff,
+		PCFGID_vendor_IDT_v		= 0x111d,
+	PCFGID_device_b 	= 16,
+	PCFGID_device_m 	= 0xffff0000,
+		PCFGID_device_Korinade_v	= 0x0214,
+
+	PCFG04_command_ioena_b		= 1,
+	PCFG04_command_ioena_m		= 0x00000001,
+	PCFG04_command_memena_b 	= 2,
+	PCFG04_command_memena_m 	= 0x00000002,
+	PCFG04_command_bmena_b		= 3,
+	PCFG04_command_bmena_m		= 0x00000004,
+	PCFG04_command_mwinv_b		= 5,
+	PCFG04_command_mwinv_m		= 0x00000010,
+	PCFG04_command_parena_b 	= 7,
+	PCFG04_command_parena_m 	= 0x00000040,
+	PCFG04_command_serrena_b	= 9,
+	PCFG04_command_serrena_m	= 0x00000100,
+	PCFG04_command_fastbbena_b	= 10,
+	PCFG04_command_fastbbena_m	= 0x00000200,
+	PCFG04_status_b 		= 16,
+	PCFG04_status_m 		= 0xffff0000,
+	PCFG04_status_66MHz_b		= 21,	// 66 MHz enable
+	PCFG04_status_66MHz_m		= 0x00200000,
+	PCFG04_status_fbb_b		= 23,
+	PCFG04_status_fbb_m		= 0x00800000,
+	PCFG04_status_mdpe_b		= 24,
+	PCFG04_status_mdpe_m		= 0x01000000,
+	PCFG04_status_dst_b		= 25,
+	PCFG04_status_dst_m		= 0x06000000,
+	PCFG04_status_sta_b		= 27,
+	PCFG04_status_sta_m		= 0x08000000,
+	PCFG04_status_rta_b		= 28,
+	PCFG04_status_rta_m		= 0x10000000,
+	PCFG04_status_rma_b		= 29,
+	PCFG04_status_rma_m		= 0x20000000,
+	PCFG04_status_sse_b		= 30,
+	PCFG04_status_sse_m		= 0x40000000,
+	PCFG04_status_pe_b		= 31,
+	PCFG04_status_pe_m		= 0x40000000,
+
+	PCFG08_revId_b			= 0,
+	PCFG08_revId_m			= 0x000000ff,
+	PCFG08_classCode_b		= 0,
+	PCFG08_classCode_m		= 0xffffff00,
+		PCFG08_classCode_bridge_v	= 06,
+		PCFG08_classCode_proc_v 	= 0x0b3000, // processor-MIPS
+	PCFG0C_cacheline_b		= 0,
+	PCFG0C_cacheline_m		= 0x000000ff,
+	PCFG0C_masterLatency_b		= 8,
+	PCFG0C_masterLatency_m		= 0x0000ff00,
+	PCFG0C_headerType_b		= 16,
+	PCFG0C_headerType_m		= 0x00ff0000,
+	PCFG0C_bist_b			= 24,
+	PCFG0C_bist_m			= 0xff000000,
+
+	PCIPBA_msi_b			= 0,
+	PCIPBA_msi_m			= 0x00000001,
+	PCIPBA_p_b			= 3,
+	PCIPBA_p_m			= 0x00000004,
+	PCIPBA_baddr_b			= 8,
+	PCIPBA_baddr_m			= 0xffffff00,
+
+	PCFGSS_vendorId_b		= 0,
+	PCFGSS_vendorId_m		= 0x0000ffff,
+	PCFGSS_id_b			= 16,
+	PCFGSS_id_m			= 0xffff0000,
+
+	PCFG3C_interruptLine_b		= 0,
+	PCFG3C_interruptLine_m		= 0x000000ff,
+	PCFG3C_interruptPin_b		= 8,
+	PCFG3C_interruptPin_m		= 0x0000ff00,
+	PCFG3C_minGrant_b		= 16,
+	PCFG3C_minGrant_m		= 0x00ff0000,
+	PCFG3C_maxLat_b 		= 24,
+	PCFG3C_maxLat_m 		= 0xff000000,
+
+	PCIPBAC_msi_b			= 0,
+	PCIPBAC_msi_m			= 0x00000001,
+	PCIPBAC_p_b			= 1,
+	PCIPBAC_p_m			= 0x00000002,
+	PCIPBAC_size_b			= 2,
+	PCIPBAC_size_m			= 0x0000007c,
+	PCIPBAC_sb_b			= 7,
+	PCIPBAC_sb_m			= 0x00000080,
+	PCIPBAC_pp_b			= 8,
+	PCIPBAC_pp_m			= 0x00000100,
+	PCIPBAC_mr_b			= 9,
+	PCIPBAC_mr_m			= 0x00000600,
+		PCIPBAC_mr_read_v	=0,	//no prefetching
+		PCIPBAC_mr_readLine_v	=1,
+		PCIPBAC_mr_readMult_v	=2,
+	PCIPBAC_mrl_b			= 11,
+	PCIPBAC_mrl_m			= 0x00000800,
+	PCIPBAC_mrm_b			= 12,
+	PCIPBAC_mrm_m			= 0x00001000,
+	PCIPBAC_trp_b			= 13,
+	PCIPBAC_trp_m			= 0x00002000,
+
+	PCFG40_trdyTimeout_b		= 0,
+	PCFG40_trdyTimeout_m		= 0x000000ff,
+	PCFG40_retryLim_b		= 8,
+	PCFG40_retryLim_m		= 0x0000ff00,
+};
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBA_baddr_b		= 0,		// In PCI_t -> pcilba [] .a
+	PCILBA_baddr_m		= 0xffffff00,
+} ;
+/*******************************************************************************
+ *
+ * PCI Local Base Address Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAC_msi_b		= 0,		// In pPci->pcilba[i].c
+	PCILBAC_msi_m		= 0x00000001,
+		PCILBAC_msi_mem_v	= 0,
+		PCILBAC_msi_io_v	= 1,
+	PCILBAC_size_b		= 2,	// In pPci->pcilba[i].c
+	PCILBAC_size_m		= 0x0000007c,
+	PCILBAC_sb_b		= 7,	// In pPci->pcilba[i].c
+	PCILBAC_sb_m		= 0x00000080,
+	PCILBAC_rt_b		= 8,	// In pPci->pcilba[i].c
+	PCILBAC_rt_m		= 0x00000100,
+		PCILBAC_rt_noprefetch_v = 0, // mem read
+		PCILBAC_rt_prefetch_v	= 1, // mem readline
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Mapping Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAM_maddr_b 	= 8,
+	PCILBAM_maddr_m 	= 0xffffff00,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAC_den_b		= 0,
+	PCIDAC_den_m		= 0x00000001,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAS_d_b	= 0,
+	PCIDAS_d_m	= 0x00000001,
+	PCIDAS_b_b	= 1,
+	PCIDAS_b_m	= 0x00000002,
+	PCIDAS_e_b	= 2,
+	PCIDAS_e_m	= 0x00000004,
+	PCIDAS_ofe_b	= 3,
+	PCIDAS_ofe_m	= 0x00000008,
+	PCIDAS_off_b	= 4,
+	PCIDAS_off_m	= 0x00000010,
+	PCIDAS_ife_b	= 5,
+	PCIDAS_ife_m	= 0x00000020,
+	PCIDAS_iff_b	= 6,
+	PCIDAS_iff_m	= 0x00000040,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 8 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA8C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA8C_mbs_m	= 0x00000fff,	// { pcidma8c }
+	PCIDMA8C_our_b	= 12,		// Optimize Unaligned Burst Reads.
+	PCIDMA8C_our_m	= 0x00001000,	// { pcidma8c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 9 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA9C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA9C_mbs_m	= 0x00000fff, // { pcidma9c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel 9)Descriptors
+ *
+ ******************************************************************************/
+enum {
+	PCIDMAD_pt_b		= 22,		// in DEVCMD field (descriptor)
+	PCIDMAD_pt_m		= 0x00c00000,	// preferred transaction field
+		// These are for reads (DMA channel 8)
+		PCIDMAD_devcmd_mr_v	= 0,	//memory read
+		PCIDMAD_devcmd_mrl_v	= 1,	//memory read line
+		PCIDMAD_devcmd_mrm_v	= 2,	//memory read multiple
+		PCIDMAD_devcmd_ior_v	= 3,	//I/O read
+		// These are for writes (DMA channel 9)
+		PCIDMAD_devcmd_mw_v	= 0,	//memory write
+		PCIDMAD_devcmd_mwi_v	= 1,	//memory write invalidate
+		PCIDMAD_devcmd_iow_v	= 3,	//I/O write
+
+	// Swap byte field applies to both DMA channel 8 and 9
+	PCIDMAD_sb_b		= 24,		// in DEVCMD field (descriptor)
+	PCIDMAD_sb_m		= 0x01000000,	// swap byte field
+} ;
+
+
+/*******************************************************************************
+ *
+ * PCI Target Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCITC_rtimer_b		= 0,		// In PCITC_t -> pcitc
+	PCITC_rtimer_m		= 0x000000ff,
+	PCITC_dtimer_b		= 8,		// In PCITC_t -> pcitc
+	PCITC_dtimer_m		= 0x0000ff00,
+	PCITC_rdr_b		= 18,		// In PCITC_t -> pcitc
+	PCITC_rdr_m		= 0x00040000,
+	PCITC_ddt_b		= 19,		// In PCITC_t -> pcitc
+	PCITC_ddt_m		= 0x00080000,
+} ;
+/*******************************************************************************
+ *
+ * PCI messaging unit [applies to both inbound and outbound registers ]
+ *
+ ******************************************************************************/
+enum
+{
+	PCIM_m0_b	= 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m0_m	= 0x00000001,	// inbound or outbound message 0
+	PCIM_m1_b	= 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m1_m	= 0x00000002,	// inbound or outbound message 1
+	PCIM_db_b	= 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_db_m	= 0x00000004,	// inbound or outbound doorbell
+};
+
+
+
+
+
+
+#define PCI_MSG_VirtualAddress	     0xB8088010
+#define rc32434_pci ((volatile PCI_t) PCI0_VirtualAddress)
+#define rc32434_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)
+
+#define PCIM_SHFT		0x6
+#define PCIM_BIT_LEN		0x7
+#define PCIM_H_EA		0x3
+#define PCIM_H_IA_FIX		0x4
+#define PCIM_H_IA_RR		0x5
+
+#define PCI_ADDR_START		0x50000000
+
+#define CPUTOPCI_MEM_WIN	0x02000000
+#define CPUTOPCI_IO_WIN		0x00100000
+#define PCILBA_SIZE_SHFT	2
+#define PCILBA_SIZE_MASK	0x1F
+#define SIZE_256MB		0x1C
+#define SIZE_128MB		0x1B
+#define SIZE_64MB               0x1A
+#define SIZE_32MB		0x19
+#define SIZE_16MB               0x18
+#define SIZE_4MB		0x16
+#define SIZE_2MB		0x15
+#define SIZE_1MB		0x14
+#define KORINA_CONFIG0_ADDR	0x80000000
+#define KORINA_CONFIG1_ADDR	0x80000004
+#define KORINA_CONFIG2_ADDR	0x80000008
+#define KORINA_CONFIG3_ADDR	0x8000000C
+#define KORINA_CONFIG4_ADDR	0x80000010
+#define KORINA_CONFIG5_ADDR	0x80000014
+#define KORINA_CONFIG6_ADDR	0x80000018
+#define KORINA_CONFIG7_ADDR	0x8000001C
+#define KORINA_CONFIG8_ADDR	0x80000020
+#define KORINA_CONFIG9_ADDR	0x80000024
+#define KORINA_CONFIG10_ADDR	0x80000028
+#define KORINA_CONFIG11_ADDR	0x8000002C
+#define KORINA_CONFIG12_ADDR	0x80000030
+#define KORINA_CONFIG13_ADDR	0x80000034
+#define KORINA_CONFIG14_ADDR	0x80000038
+#define KORINA_CONFIG15_ADDR	0x8000003C
+#define KORINA_CONFIG16_ADDR	0x80000040
+#define KORINA_CONFIG17_ADDR	0x80000044
+#define KORINA_CONFIG18_ADDR	0x80000048
+#define KORINA_CONFIG19_ADDR	0x8000004C
+#define KORINA_CONFIG20_ADDR	0x80000050
+#define KORINA_CONFIG21_ADDR	0x80000054
+#define KORINA_CONFIG22_ADDR	0x80000058
+#define KORINA_CONFIG23_ADDR	0x8000005C
+#define KORINA_CONFIG24_ADDR	0x80000060
+#define KORINA_CONFIG25_ADDR	0x80000064
+#define KORINA_CMD 		(PCFG04_command_ioena_m | \
+				 PCFG04_command_memena_m | \
+				 PCFG04_command_bmena_m | \
+				 PCFG04_command_mwinv_m | \
+				 PCFG04_command_parena_m | \
+				 PCFG04_command_serrena_m )
+
+#define KORINA_STAT		(PCFG04_status_mdpe_m | \
+				 PCFG04_status_sta_m  | \
+				 PCFG04_status_rta_m  | \
+				 PCFG04_status_rma_m  | \
+				 PCFG04_status_sse_m  | \
+				 PCFG04_status_pe_m)
+
+#define KORINA_CNFG1		((KORINA_STAT<<16)|KORINA_CMD)
+
+#define KORINA_REVID		0
+#define KORINA_CLASS_CODE	0
+#define KORINA_CNFG2		((KORINA_CLASS_CODE<<8) | \
+				  KORINA_REVID)
+
+#define KORINA_CACHE_LINE_SIZE	4
+#define KORINA_MASTER_LAT	0x3c
+#define KORINA_HEADER_TYPE	0
+#define KORINA_BIST		0
+
+#define KORINA_CNFG3 ((KORINA_BIST << 24) | \
+		      (KORINA_HEADER_TYPE<<16) | \
+		      (KORINA_MASTER_LAT<<8) | \
+		      KORINA_CACHE_LINE_SIZE )
+
+#define KORINA_BAR0	0x00000008 /* 128 MB Memory */
+#define KORINA_BAR1	0x18800001 /* 1 MB IO */
+#define KORINA_BAR2	0x18000001 /* 2 MB IO window for Korina
+					internal Registers */
+#define KORINA_BAR3	0x48000008 /* Spare 128 MB Memory */
+
+#define KORINA_CNFG4	KORINA_BAR0
+#define KORINA_CNFG5    KORINA_BAR1
+#define KORINA_CNFG6 	KORINA_BAR2
+#define KORINA_CNFG7	KORINA_BAR3
+
+#define KORINA_SUBSYS_VENDOR_ID 0x011d
+#define KORINA_SUBSYSTEM_ID	0x0214
+#define KORINA_CNFG8		0
+#define KORINA_CNFG9		0
+#define KORINA_CNFG10		0
+#define KORINA_CNFG11 	((KORINA_SUBSYS_VENDOR_ID<<16) | \
+			  KORINA_SUBSYSTEM_ID)
+#define KORINA_INT_LINE		1
+#define KORINA_INT_PIN		1
+#define KORINA_MIN_GNT		8
+#define KORINA_MAX_LAT		0x38
+#define KORINA_CNFG12		0
+#define KORINA_CNFG13 		0
+#define KORINA_CNFG14		0
+#define KORINA_CNFG15	((KORINA_MAX_LAT<<24) | \
+			 (KORINA_MIN_GNT<<16) | \
+			 (KORINA_INT_PIN<<8)  | \
+			  KORINA_INT_LINE)
+#define	KORINA_RETRY_LIMIT	0x80
+#define KORINA_TRDY_LIMIT	0x80
+#define KORINA_CNFG16 ((KORINA_RETRY_LIMIT<<8) | \
+			KORINA_TRDY_LIMIT)
+#define PCI_PBAxC_R		0x0
+#define PCI_PBAxC_RL		0x1
+#define PCI_PBAxC_RM		0x2
+#define SIZE_SHFT		2
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | PCIPBAC_sb_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#else
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#endif
+#define KORINA_CNFG17	KORINA_PBA0C
+#define KORINA_PBA0M	0x0
+#define KORINA_CNFG18	KORINA_PBA0M
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+#endif
+#define KORINA_CNFG19	KORINA_PBA1C
+#define KORINA_PBA1M	0x0
+#define KORINA_CNFG20	KORINA_PBA1M
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+#endif
+#define KORINA_CNFG21	KORINA_PBA2C
+#define KORINA_PBA2M	0x18000000
+#define KORINA_CNFG22	KORINA_PBA2M
+#define KORINA_PBA3C	0
+#define KORINA_CNFG23	KORINA_PBA3C
+#define KORINA_PBA3M	0
+#define KORINA_CNFG24	KORINA_PBA3M
+
+
+
+#define	PCITC_DTIMER_VAL	8
+#define PCITC_RTIMER_VAL	0x10
+
+
+
+
+#endif	// __IDT_PCI_H__
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/rb.h linux.dev/include/asm-mips/rc32434/rb.h
--- linux.old/include/asm-mips/rc32434/rb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/rb.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,84 @@
+/*
+ *  Copyright (C) 2004 IDT Inc.
+ *  Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ */
+#ifndef __MIPS_RB_H__
+#define __MIPS_RB_H__
+#include <linux/genhd.h>
+
+#define IDT434_REG_BASE ((volatile void *) KSEG1ADDR(0x18000000))
+#define DEV0BASE 0x010000
+#define DEV0MASK 0x010004
+#define DEV0C 0x010008
+#define DEV0TC 0x01000C
+#define DEV1BASE 0x010010
+#define DEV1MASK 0x010014
+#define DEV1C 0x010018
+#define DEV1TC 0x01001C
+#define DEV2BASE 0x010020
+#define DEV2MASK 0x010024
+#define DEV2C 0x010028
+#define DEV2TC 0x01002C
+#define DEV3BASE 0x010030
+#define DEV3MASK 0x010034
+#define DEV3C 0x010038
+#define DEV3TC 0x01003C
+#define BTCS 0x010040
+#define BTCOMPARE 0x010044
+#define GPIOFUNC 0x050000
+#define GPIOCFG 0x050004
+#define GPIOD 0x050008
+#define GPIOILEVEL 0x05000C
+#define GPIOISTAT 0x050010
+#define GPIONMIEN 0x050014
+#define IMASK6 0x038038
+
+#define LO_WPX (1 << 0)
+#define LO_ALE (1 << 1)
+#define LO_CLE (1 << 2)
+#define LO_CEX (1 << 3)
+#define LO_FOFF (1 << 5)
+#define LO_SPICS (1 << 6)
+#define LO_ULED (1 << 7)
+
+typedef enum {
+	FUNC = 0x00,
+	CFG = 0x04,
+	DATA = 0x08,
+	ILEVEL = 0x0c,
+	ISTAT = 0x10,
+	NMIEN = 0x14
+} gpio_func;
+
+extern void changeLatchU5(unsigned char orMask, unsigned char nandMask);
+extern unsigned get434Reg(unsigned regOffs);
+extern void set434Reg(unsigned regOffs, unsigned bit, unsigned len, unsigned val);
+extern void gpio_set(gpio_func func, u32 mask, u32 value);
+extern u32 gpio_get(gpio_func func);
+
+#define get434Reg(x) (*(volatile unsigned *) (IDT434_REG_BASE + (x)))
+
+struct korina_device {
+	char *name;
+	unsigned char mac[6];
+	struct net_device *dev;
+};
+
+struct cf_device {
+	int gpio_pin;
+	void *dev;
+	struct gendisk *gd;
+};
+
+#endif
diff -urN linux.old/include/asm-mips/rc32434/rc32434.h linux.dev/include/asm-mips/rc32434/rc32434.h
--- linux.old/include/asm-mips/rc32434/rc32434.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/rc32434.h	2006-12-14 04:09:50.000000000 +0100
@@ -0,0 +1,122 @@
+/*
+ ***************************************************************************
+ * Definitions for IDT RC323434 CPU.
+ *
+ ****************************************************************************
+ * Kiran Rao
+ * 
+ * Original form
+ ****************************************************************************
+ * P. Sadik   Oct 08, 2003
+ *
+ * Started revision history
+ * Made IDT_BUS_FREQ a kernel configuration parameter
+ ****************************************************************************
+ * P. Sadik   Oct 10, 2003
+ *
+ * Removed IDT_BUS_FREQ, since this parameter is no longer required. Instead
+ * idt_cpu_freq is used everywhere
+ ****************************************************************************
+ * P. Sadik   Oct 20, 2003
+ *
+ * Removed RC32434_BASE_BAUD
+ ****************************************************************************
+*/
+#ifndef _RC32434_H_
+#define _RC32434_H_
+
+#include <linux/autoconf.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#define RC32434_REG_BASE   0x18000000
+
+#define interrupt ((volatile INT_t ) INT0_VirtualAddress)
+#define gpio	  ((volatile GPIO_t) GPIO0_VirtualAddress)
+
+
+#define IDT_CLOCK_MULT 2
+#define MIPS_CPU_TIMER_IRQ 7
+/* Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32434_REG_BASE + 0x38000)
+#define IC_GROUP0_MASK     (RC32434_REG_BASE + 0x38008)
+#define IC_GROUP_OFFSET    0x0C
+
+#define NUM_INTR_GROUPS    5
+/* 16550 UARTs */
+
+#define GROUP0_IRQ_BASE 8		/* GRP2 IRQ numbers start here */
+#define GROUP1_IRQ_BASE (GROUP0_IRQ_BASE + 32) /* GRP3 IRQ numbers start here */
+#define GROUP2_IRQ_BASE (GROUP1_IRQ_BASE + 32) /* GRP4 IRQ numbers start here */
+#define GROUP3_IRQ_BASE (GROUP2_IRQ_BASE + 32)	/* GRP5 IRQ numbers start here */
+#define GROUP4_IRQ_BASE (GROUP3_IRQ_BASE + 32)
+
+
+#ifdef __MIPSEB__
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58003)
+#else
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58000)
+#endif
+
+#define RC32434_UART0_IRQ  GROUP3_IRQ_BASE + 0
+// #define EB434_UART1_IRQ    GROUP4_IRQ_BASE + 11
+
+#define local_readl(addr) __raw_readl(addr)
+#define local_writel(l,addr) __raw_writel(l,addr)
+
+/* cpu pipeline flush */
+static inline void rc32434_sync(void)
+{
+        __asm__ volatile ("sync");
+}
+
+static inline void rc32434_sync_udelay(int us)
+{
+        __asm__ volatile ("sync");
+        udelay(us);
+}
+
+static inline void rc32434_sync_delay(int ms)
+{
+        __asm__ volatile ("sync");
+        mdelay(ms);
+}
+
+/*
+ * C access to CLZ and CLO instructions
+ * (count leading zeroes/ones).
+ */
+static inline int rc32434_clz(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clz\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+static inline int rc32434_clo(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clo\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+
+#endif /* _RC32434_H_ */

